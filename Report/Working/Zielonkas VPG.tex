\documentclass[]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{eurosym}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\DeclareRobustCommand{\officialeuro}{%
	\ifmmode\expandafter\text\fi
	{\fontencoding{U}\fontfamily{eurosym}\selectfont e}}
\usepackage{caption}
\usepackage{subcaption}
\usetikzlibrary{matrix}
\usepackage{ stmaryrd }
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}



%opening
\title{Verifying Featured Transition Systems using Variability Parity Games}
\author{Sjef van Loo}

\begin{document}
\section{Recursive algorithm}
\subsection{Original Zielonka's recursive algorithm}
The original Zielonka's recursive algorithm,created from the constructive prove given in \cite{ZIELONKA1998135}, is defined for a total PG (ie. an infinite game).
\begin{algorithm}[h]
	\caption{$\textsc{RecursivePG}(\textit{PG } G = (V,V_0,V_1, E, \Omega)$}
	\begin{algorithmic}[1]
		\State $m \gets \min\{ \Omega(v)\ |\ v \in V\}$
		\State $h \gets\max\{ \Omega(v)\ |\ v \in V\}$
		\If{$h = m$ or $V = \emptyset$}
		\If{$h$ is even or $V = \emptyset$}
		\State \Return $(V,\emptyset)$
		\Else
		\State \Return $(\emptyset, V)$
		\EndIf
		\EndIf
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{v \in V\ |\ \Omega(v) = h\}$
		\State $A \gets \alpha\textit{-Attr}(G, U)$
		\State $(W_0', W_1') \gets \textsc{RecursivePG}(G \backslash A)$
		\If{$W_{\overline{\alpha}}' =\emptyset$}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-Attr}(G,W_{\overline{\alpha}}')$
		\State $(W_0'', W_1'') \gets \textsc{RecursivePG}(G \backslash B)$
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}
\begin{definition}\cite{ZIELONKA1998135}
	\label{def_org_subgame}
	Given a parity game $G = (V,V_0,V_1, E,\Omega)$ and $U \subseteq V$ we define the subgame $G \backslash U$ to be the game $(V', V_0', V_1', E', \Omega)$ with:
	\begin{itemize}
		\item $V' = V \backslash U$,
		\item $V_0' = V_0 \cap V'$,
		\item $V_1' = V_1 \cap V'$ and
		\item $E' = E \cap (V' \times V')$.
	\end{itemize}
\end{definition}

\begin{definition}\cite{ZIELONKA1998135}
	\label{def_trap}
	A set $U \subseteq V$ is an $\alpha$-trap for PG G iff:
	\begin{align*}
	\forall v &\in U:\\
	&v \in V_\alpha \implies \forall(v,w) \in E : w \in U\\
	&\wedge\\
	&v \in V_{\overline{\alpha}} \implies \exists (v,w) \in E : w \in U
	\end{align*}
	If the token is in $\alpha$-trap $U$ then player $\overline{\alpha}$ can play a strategy such that the token always remains in $U$.
\end{definition}

\begin{definition}\cite{ZIELONKA1998135}
	\label{def_attr}
	For a non-empty set $U \subseteq V$ we define $\alpha\textit{-Attr}(G,U)$ such that
	\[U_0 = U \]
	For $i \geq 0$:
	\begin{align*}
	U_{i+1} = &\{v \in V_\alpha\ |\ \exists v' \in V : v' \in U_i \wedge (v,v') \in E \}\\
	\cup &\{v \in V_{\overline{\alpha}}\ |\ \forall v' \in V :(v,v') \in E \implies v' \in U_i \}
	\end{align*}
	\[\alpha\textit{-Attr}(G,U) = U_k \]
	such that for $k$ we have
	\[U_k = U_{k+1} \]
\end{definition}

\begin{lemma}\cite{ZIELONKA1998135}
	\label{lem_ZIELONKA_attr_is_trap}
	Given PG $G = (V, V_0, V_1, E, \Omega)$, set $X \subseteq V$ and player $\alpha$ it holds that $V\backslash \alpha\textit{-Attr}(G,X)$ is an $\alpha$-trap in $G$.
\end{lemma}

\subsection{Recursive algorithm for VPGs}
	\begin{definition}
		\label{def_MPG}
		A multidimensional parity game (MPG) is a parity game defined over a set of configuration $\mathfrak{C}$ and a set of origin vertices $\mathfrak{V}$. Every vertex is represented by a pair of a configuration and an origin vertex. We have MPG being a tuple $G = (V,V_0,V_1,E,\Omega)$ such that:
		\begin{itemize}
			\item $V \subseteq \mathfrak{C} \times \mathfrak{V}$,
			\item $V_0 \uplus V_1 = V$,
			\item $E \subseteq V \times V$ such that $((c,v),(c',v')) \in E \implies c =c'$ and
			\item $\Omega : \mathfrak{V} \rightarrow \mathbb{N}$.
		\end{itemize}
	MPGs are total, ie. for every $(c,v) \in V$ there exists an $(c,w) \in V$ such that $((c,v),(c,w)) \in E$.
	\end{definition}
	\begin{definition}
		\label{def_con_MPG}
		For a set $X \subseteq \mathfrak{C} \times \mathfrak{V}$ we define $con(X) \subseteq \mathfrak{C}$ to be the set of configurations that occur in $X$, formally: $con(X) = \{c\ |\ (c,v) \in X\}$.
	\end{definition}
	\begin{definition}
		\label{def_cV}
		For a set $X \subseteq \mathfrak{C} \times \mathfrak{V}$ we define $cX = \{ v \in \mathfrak{V}\ |\ (c,v) \in X\}$ and $Xv = \{ c \in \mathfrak{C}\ |\ (c,v) \in X\}$.
	\end{definition}
	\begin{definition}
		\label{def_cE}
		For a set $E \subseteq (\mathfrak{C} \times \mathfrak{V}) \times (\mathfrak{C} \times \mathfrak{V})$ we define $cE = \{(v,w)\ |\ ((c,v),(c,w)) \in E \}$.
	\end{definition}
	\begin{definition}
		\label{def_cG}
		An MPG $G = (V,V_0,V_1,E,\Omega)$ can be played for a configuration $c \in \mathfrak{C}$ which is playing PG $(cV,cV_0,cV_1,cE,\Omega)$, we denote this as $cG$.
	\end{definition}
	Note that it follows immediately that for every $c \in \mathfrak{C}$ and MPG $G$ defined over $\mathfrak{C}$ it holds that game $cG$ is total, ie. for every $v \in cV$ there exists an $w \in cV$ such that $(v,w) \in E$.
	\begin{definition}
		\label{def_MAttr}
		\[U_0 = U \]
		For $i \geq 0$:
		\begin{align*}
		U_{i+1} = &\{(c,v) \in V_\alpha\ |\ \exists (c,v') \in V : (c, v') \in U_i \wedge ((c,v), (c,v')) \in E \}\\
		\cup &\{(c,v) \in V_{\overline{\alpha}}\ |\ \forall (c,v') \in V :((c,v), (c,v')) \in E \implies (c, v') \in U_i \}
		\end{align*}
		\[\alpha\textit{-MAttr}(G,U) = U_k \]
		such that for $k$ we have
		\[U_k = U_{k+1} \]
	\end{definition}

	\begin{definition}
		\label{def_subgame}
		$\backslash^{\!\!M} : \textit{MPG} \rightarrow \mathcal{P}(V) \rightarrow \textit{MPG}$\\
		$(V, V_0, V_1, E, \Omega)\ \backslash^{\!\!M}\ CV = (V', V_0', V_1', E', \Omega)$ such that:\\
		$V' = V \backslash CV$\\
		$E' = E \cap (V' \times V')$\\
		$V_0' = V_0 \cap V'$\\
		$V_1' = V_1 \cap V'$
	\end{definition}
\begin{definition}
	\label{def_MTrap}
	A set $U \subseteq V$ is a $\alpha$-MTrap for MPG G iff:
\begin{align*}
\forall(c,v) &\in U:\\
&(c,v) \in V_\alpha \implies \forall((c,v),(c,w)) \in E : (c,w) \in U\\
&\wedge\\
&(c,v) \in V_{\overline{\alpha}} \implies \exists ((c,v),(c,w)) \in E : (c,w) \in U
\end{align*}
\end{definition}
\begin{algorithm}[h]
\caption{$\textsc{RecursiveMPG}(\textit{MPG } G = (V,V_0,V_1, E, \Omega)$}
\begin{algorithmic}[1]
	\State $m \gets \min\{ \Omega(v)\ |\ (c,v) \in V\}$
	\State $h \gets\max\{ \Omega(v)\ |\ (c,v) \in V\}$
	\If{$h = m$ or $V = \emptyset$}
	\If{$h$ is even or $V = \emptyset$}
	\State \Return $(V,\emptyset)$
	\Else
	\State \Return $(\emptyset, V)$
	\EndIf
	\EndIf
	\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
	\State $U \gets \{(c,v) \in V\ |\ \Omega(v) = h\}$
	\State $A \gets \alpha\textit{-MAttr}(G, U)$
	\State $(W_0', W_1') \gets \textsc{RecursiveMPG}(G \backslash^{\!\!M} A)$
	\If{$W_{\overline{\alpha}}' =\emptyset$}
	\State $W_\alpha \gets A \cup W_\alpha'$
	\State $W_{\overline{\alpha}} \gets \emptyset$
	\Else
	\State $B \gets \overline{\alpha}\textit{-MAttr}(G,W_{\overline{\alpha}}')$
	\State $(W_0'', W_1'') \gets \textsc{RecursiveMPG}(G \backslash^{\!\!M} B)$
	\State $W_\alpha \gets W_\alpha''$
	\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
	\EndIf
	\State \Return $(W_0, W_1)$
\end{algorithmic}
\end{algorithm}
%\input{proofzlnk}
\input{proofexhaustive.tex}
\bibliography{../mybib} 
\bibliographystyle{ieeetr}
\end{document}