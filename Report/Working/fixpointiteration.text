\documentclass[]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{eurosym}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\DeclareRobustCommand{\officialeuro}{%
	\ifmmode\expandafter\text\fi
	{\fontencoding{U}\fontfamily{eurosym}\selectfont e}}
\usepackage{caption}
\usepackage{subcaption}
\usetikzlibrary{matrix}

\usepackage{stmaryrd}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}



%opening
\title{Verifying Featured Transition Systems using Variability Parity Games}
\author{Sjef van Loo}

\begin{document}
	\section{Fixed point iteration}

	\section{Alg}
Define $\cap : \textit{VPG} \rightarrow \mathcal{P}(\mathfrak{C}) \rightarrow \textit{VPG}$\\
$(V,V_0,V_1,E,\Omega,\mathfrak{C},\theta) \cap \mathfrak{C}' = (V,V_0,V_1,E',\Omega,\mathfrak{C}', \theta')$ such that:\\
$\mathfrak{C}' = \mathfrak{C} \cap \mathfrak{C}'$\\
$\theta'(e) = \theta(e) \cap \mathfrak{C}'$ for every $e \in E$\\
$E' = \{e \in E\ |\ \theta'(e) \neq \emptyset \}$

Let \textsc{DASolve} be a dominion aware parity game solve algorithm, such an algorithm uses the dominions that are already known. Given \textsc{DASolve} we can solve a VPG using the following algorithm:
\begin{algorithm}
	\caption{$\textsc{SuperDominionMBR}(G, D_0, D_1)$}
	\begin{algorithmic}[1]
		\If{$|\mathfrak{C}| = 1$}
			\State $(W_0,W_1) \gets \textsc{DASolve}(G,D_0,D_1)$
			\State \Return $(\mathfrak{C} \times W_0, \mathfrak{C} \times W_1)$
		\EndIf
		\State $(D_0', -) \gets \textsc{DASolve}(0{-}Gen(G),D_0,D_1)$
		\State $(-, D_1') \gets \textsc{DASolve}(1{-}Gen(G),D_0,D_1)$
		\If{$D_0' \cup D_1' = V$}
		\State \Return $(\mathfrak{C} \times D_0', \mathfrak{C} \times D_1')$
		\EndIf
		\State $(\mathfrak{C}^a,\mathfrak{C}^b) \gets$ partition $\mathfrak{C}$ in non-empty parts
		\State $(W_0^a, W_1^a) \gets \textsc{SuperDominionMBR}(G \cap \mathfrak{C}^a,D_0',D_1')$
		\State $(W_0^b, W_1^b) \gets \textsc{SuperDominionMBR}(G \cap \mathfrak{C}^b,D_0',D_1')$
		\State $W_0 \gets W_0^a \cup W_0^b$
		\State $W_1 \gets W_1^a \cup W_1^b$
		\State \Return $(W_0,W_1)$
	\end{algorithmic}
\end{algorithm}

Any parity game algorithm \textsc{Solve} can be transformed in a dominion aware algorithm by using the following transformation:
\begin{algorithm}
	\caption{$\textsc{DASolveGeneric}(G, D_0, D_1)$}
	\begin{algorithmic}[1]
		\For{$\alpha \in \{0,1\}$}
			\State Replace $D_\alpha$ in $G$ with a single vertex $d_\alpha$ with priority $\alpha$ and a selfloop. All edges going from $D_\alpha$ are removed. Edges going from $v \in V_\alpha$ to $D_\alpha$ are replaced with $(v,d_\alpha)$. Edges going from $v \in V_{\overline{\alpha}}$ to $D_\alpha$ are removed.
		\EndFor
		\State $(W_0, W_1) \gets \textsc{Solve(G)}$
		\State \Return $(W_0 \backslash \{d_0\} \cup D_0, W_1 \backslash \{d_1\} \cup D_1)$
	\end{algorithmic}
\end{algorithm}

\section{Fixpoint iteration}
For some algorithms, specifically iteration algorithms, we can use the internal structure instead of using super dominions. For example for the fixpoint iterator we can use the values of the variables.\\
\begin{algorithm}
	\caption{$\textsc{FixpointIterMBR}(G, (Z_{n-1}, \dots, Z_0))$}
	\begin{algorithmic}[1]
		\If{$|\mathfrak{C}| = 1$}
			\State $(Z_{n-1}',\dots,Z_0') \gets $ fixpoint iterate over game $G$ starting at $Z_{n-1},\dots,Z_0$
			\State \Return $(\mathfrak{C} \times Z_{n-1}', \mathfrak{C} \times (V \backslash Z_{n-1}'))$
		\EndIf
		\State $(Z_{n-1}^0,\dots,Z_0^0) \gets $ fixpoint iterate over game $0{-}Gen(G)$ starting at $Z_{n-1},\dots,Z_0$
		\State $(Z_{n-1}^1,\dots,Z_0^1) \gets $ fixpoint iterate over game $1{-}Gen(G)$ starting at $Z_{n-1},\dots,Z_0$
		\State $Z_i' \gets Z_i^{i - 1 \mod 2}$ for every $i \in [n-1]$
		\State $(\mathfrak{C}^a,\mathfrak{C}^b) \gets$ partition $\mathfrak{C}$ in non-empty parts
		\State $(W_0^a, W_1^a) \gets \textsc{FixpointIterMBR}(G \cap \mathfrak{C}^a,(Z_{n-1}',\dots,Z_0'))$
		\State $(W_0^b, W_1^b) \gets \textsc{FixpointIterMBR}(G \cap \mathfrak{C}^b,(Z_{n-1}',\dots,Z_0'))$
		\State $W_0 \gets W_0^a \cup W_0^b$
		\State $W_1 \gets W_1^a \cup W_1^b$
		\State \Return $(W_0,W_1)$
	\end{algorithmic}
\end{algorithm}\\
Fixpoint equation:
\begin{align*}
F_0(Z_{n-1}, \dots, Z_1) = \{&x\in V\ |\ \\
&(x \in V_0 \implies \exists_y : ((x,y) \in E \wedge y \in Z_{\Omega(y)} ))\\
& \wedge\\
&(x \in V_1 \implies \forall_y : ((x,y) \in E \implies y \in Z_{\Omega(y)}))\\
&\}
\end{align*}
\[ W_0 = \sigma Z_{n-1}\dots \mu Z_1. \nu Z_0.F_0(Z_{n-1}, \dots, Z_1) \]
Every $Z_i$ has fixpoint operator $\nu$ if $i$ is even and $\mu$ if $i$ is odd.\\
Claim: For game $0{-}Gen(G \cap \mathfrak{C}')$ we have that $F_0$ increases when $\mathfrak{C}'$ decreases.\\
Claim: For game $1{-}Gen(G \cap \mathfrak{C}')$ we have that $F_0$ decreases when $\mathfrak{C}'$ decreases.\\
Note that fixpoint iteration works for games with deadlocks.

\section{Small progress measure}
For game $0{-}Gen(G\cup\mathfrak{C}')$ it holds that the progress measure is larger or smaller when $\mathfrak{C}'$ decreases. I think.
\end{document}