We evaluate the performance of the algorithms on numerous test cases. We have two SPL model checking problems as well as random VPGs. The model checking VPGs are created as described in chapter \ref{part:verifying}, with the exception that only vertices are added when they are reachable from the initial vertex. So these games are never disjointed. Random games can be disjointed. 

In this section we present the different test cases and their characteristics. In the next section the running times are presented.

\subsection{Model checking games}
We use two SPL examples. First, the minepump example as described in \cite{Kramer1983CONICAI} and implemented in the mCRL2 toolset \cite{mCRL2Toolset} as described in \cite{FamBasedModelCheckingWithMCRL2}. The minepump example models the behaviour of controllers for a pump that pumps water out of a mineshaft. There are 10 different features that change the way the sensors/actors behave. In total there are 128 valid feature assignments, i.e. products. 

The mCRL2 implementation creates an LTS with parametrized actions where the parameters describe the boolean formulas guarding the transitions, effectively making it an FTS consisting of 582 states and 1376 transitions. This FTS is interpreted in combination with nine different $\mu$-calculus formulas to create nine VPGs.

We choose to represent the sets of configurations using 10 boolean variables even though 128 configurations could be represented using only 7 boolean variables. By using the same number of variables as there are features the boolean formulas from the FTS are left intact when using them in the VPG. Table \ref{tab_minepump_formulas} shows the different formulas, as well as the result of the verification and the size of the resulting games. All the properties can be expressed in the modal $\mu$-calculus we introduced in Definition \ref{def_mu_syntax}. However, for readability, we present them using action formulas, regular formulas and universal quantifiers  \cite{Groote}.

\begin{table}
	\centering
	\begin{tabularx}{\linewidth}{|c|L|c|c|c|}
		\hline
		& formula & \textbf{t}/\textbf{f} & $n$ & $d$ \\ \hline
		
		\multirow{2}{*}{$\varphi_1$} & \textit{Absence of deadlock}& \multirow{2}{*}{$128/0$} & \multirow{2}{*}{3494} & \multirow{2}{*}{2}\\
		& $[\textbf{true}^*]\langle \textbf{true} \rangle \top$ &  & & \\ \hline
		
		\multirow{2}{*}{$\varphi_2$}& \textit{The controller cannot infinitely often receive water level readings}& \multirow{2}{*}{$0/128$} & \multirow{2}{*}{3004} & \multirow{2}{*}{3} \\
		& $\mu X. [ (\neg \textit{levelMsg})^*.\textit{levelMsg}]X$ & & &\\ \hline
		
		\multirow{2}{*}{$\varphi_3$} & \textit{The controller cannot fairly receive each of the three message types}& \multirow{2}{*}{$0/128$} & \multirow{2}{*}{9156} & \multirow{2}{*}{3}\\
		& $\mu X. ([\textbf{true}^*.\textit{commandMsg}]X \vee [\textbf{true}^*.\textit{alarmMsg}]X \vee [\textbf{true}^*.\textit{levelMsg}]X)$ & & &\\ \hline
		
		& \textit{The pump cannot be switched on infinitely often}& & &\\
		$\varphi_4$ & $(\mu X. \nu Y. ([\textit{pumpStart}.(\neg \textit{pumpStop})^*.\textit{pumpStop}]X \wedge [\neg \textit{pumpStart}]Y)) \wedge ([\textbf{true}^*.\textit{pumpStart}] \mu Z. [\neg \textit{pumpStop}]Z)$ & $96/32$ &6236 & 4\\ \hline
		
		& \textit{The system cannot be in a situation in which the pump runs indefinitely in the
			presence of methane}& & &\\
		$\varphi_5$& $[\textbf{true}^*] (( [\textit{pumpStart}.(\neg\textit{pumpStop})^*.\textit{methaneRise}] \mu X.[R]X) \wedge ([\textit{methaneRise}.(\neg\textit{methaneLower})^*.\textit{pumpStart}] \mu X.[R]X))$ &  $96/32$ &7096 &3\\
		& for $R=\neg (\textit{pumpStop}+\textit{methaneLower})$ & & &\\ \hline
		
		 \multirow{6}{*}{$\varphi_6$} & \textit{Assuming fairness ($\varphi_3$), the system cannot be in a situation in which the pump runs indefinitely in the presence of methane ($\varphi_5$)} & \multirow{6}{*}{$112/16$} & \multirow{6}{*}{9224} & \multirow{6}{*}{4}\\
		& $[\textbf{true}^*] (( [\textit{pumpStart}.(\neg\textit{pumpStop})^*.\textit{methaneRise}] \Psi) \wedge ([\textit{methaneRise}.(\neg\textit{methaneLower})^*.\textit{pumpStart}] \Psi))$ & & &\\
		& for $\Psi = \mu X.([R^*.\textit{commandMsg}]X \vee [R^*.\textit{alarmMsg}] X \vee [R^*.\textit{levelMsg}]X)$ & & &\\
		& and $R=\neg (\textit{pumpStop}+\textit{methaneLower})$ & & &\\ \hline
		
		 \multirow{3}{*}{$\varphi_7$} & \textit{The controller can always eventually receive/read a message, i.e. it can return to its initial state from any state} &  \multirow{3}{*}{$128/0$} & \multirow{3}{*}{5285} &  \multirow{3}{*}{3}\\
		& $[\textbf{true}^*]\langle \textbf{true}^*.\textit{receiveMsg}\rangle \top$& & &\\ \hline
		
		\multirow{2}{*}{$\varphi_8$}& \textit{Invariantly the pump is not started when the low water level signal fires}& \multirow{2}{*}{$128/0$} & \multirow{2}{*}{3902} & \multirow{2}{*}{2}\\
		& $[\textbf{true}^*.\textit{lowLevel}.(\neg(\textit{normalLevel}+\textit{highLevel}))^*.\textit{pumpStart}]\bot$ & & &\\ \hline
		
		\multirow{2}{*}{$\varphi_9$} & \textit{Invariantly, when the level of methane rises, it inevitably decreases}& \multirow{2}{*}{$0/128$} & \multirow{2}{*}{5418} & \multirow{2}{*}{3}\\
		& $[\textbf{true}^*.\textit{methaneRise}] \mu X.[\neg \textit{methaneLower}] X \wedge \langle \textbf{true} \rangle \top$ & & &\\ \hline
	\end{tabularx}
	\caption{Minepump properties with their partitioning and the size of the resulting VPG. In the \textbf{t}/\textbf{f} columns the first number shows for how many products the property holds. Columns $n$ and $d$ shows the number of vertices and distinct priorities in the resulting VPG. The formula column is taken verbatim from \cite{FamBasedModelCheckingWithMCRL2}}.
	\label{tab_minepump_formulas}
\end{table}


Next we have the elevator example, described in \cite{PLATH200153}. This example models the behaviour of an elevator where five different features modify the behaviour of the model. All feature assignments are valid. Therefore, we have $2^5 = 32$ feature assignments, i.e. products. Again an mCRL2 implementation\footnote{\label{note1}https://github.com/SjefvanLoo/VariabilityParityGames/blob/master/implementation/Elevator.tar.gz} (created by T.A.C. Willemse) is used to create seven VPGs. The FTS consists of 33738 states and 206290 transitions. Table \ref{tab_elevator_formulas} shows the different formulas, as well as the result of the verification and the size of the resulting games.
\begin{table}
	\centering
	\begin{tabularx}{\linewidth}{|c|L|c|c|c|}
		\hline
		& formula & \textbf{t}/\textbf{f} & $n$ & $d$ \\ \hline
		
		\multirow{4}{*}{$\varphi_1$} & \textit{If a landing button is pressed at Level i, the lift will inevitably open its doors on Level i}& \multirow{4}{*}{$2/30$} & \multirow{4}{*}{1379959} & \multirow{4}{*}{3}\\
		& $[\textbf{true}^*]\forall i \in [1,5]. [\textit{landingButton}(i)](\mu X. ([\neg \textit{open}(i)]X \wedge \langle\textbf{true}\rangle\top)$ )
		 &  & & \\ \hline
		
		
		\multirow{3}{*}{$\varphi_2$} & \textit{If a lift button is pressed at Level i, the lift will inevitably open its doors on Level i}& \multirow{3}{*}{$4/28$} & \multirow{3}{*}{1381390} & \multirow{3}{*}{3}\\
		& $[\textbf{true}^*]\forall i\in [1,5]. [\textit{liftButton}(i)](\mu X. ([\neg \textit{open}(i)]X \wedge \langle\textbf{true}\rangle\top) )$ &  & & \\ \hline
		
		\multirow{7}{*}{$\varphi_3$} & \textit{If the lift is travelling up while there are calls in that direction it will not change the direction it is travelling}& \multirow{7}{*}{$4/28$} & \multirow{7}{*}{1778065} & \multirow{7}{*}{3}\\
		& $[\textbf{true}^*]($& & & \\
		&\ \ \ $[\textit{direction}(\textit{up}).(\neg  (\textit{direction}(\textit{down}) + \exists k \in [1,5]. \textit{open}(k)))^*]$ & & &\\
		&\ \ \ $\forall i\in [1,5].[\textit{open}(i)]\forall j \in [i+1,5].$ & & & \\
		&\ \ \ \ \ \ $[\textit{liftButton}(j)]\mu Y. ($ & & & \\
		&\ \ \ \ \ \ \ \ \ $ [\neg \textit{open}(j)]Y \wedge [\textit{direction}(\textit{down})]\textbf{false} \wedge \langle\textbf{true}\rangle\top )
		)$ &  & & \\ \hline
		
		\multirow{7}{*}{$\varphi_4$} & \textit{If the lift is travelling down while there are calls in that direction it will not change the direction it is travelling}& \multirow{7}{*}{$4/28$} & \multirow{7}{*}{1853633} & \multirow{7}{*}{3}\\
		& $[\textbf{true}^*]($ & & &\\
		&\ \ \ $[\textit{direction}(\textit{down}).(\neg  (\textit{direction}(\textit{up}) + \exists k \in [1,5]. \textit{open}(k)))^*]$ & & &\\
		&\ \ \ $\forall i:\in [1,5].[\textit{open}(i)]\forall j\in [1,i-1].$ & & & \\
		&\ \ \ \ \ \ $[\textit{liftButton}(j)]\mu Y. ($ & & & \\
		&\ \ \ \ \ \ \ \ \ $ [\neg \textit{open}(j)]Y \wedge [\textit{direction}(\textit{up})]\textbf{false} \wedge \langle\textbf{true}\rangle\top )
	)$ &  & & \\ \hline
		
		\multirow{3}{*}{$\varphi_5$} & \textit{If the lift is idling on Level i, it can remain at Level i
		}& \multirow{3}{*}{$16/16$} & \multirow{3}{*}{1282147} & \multirow{3}{*}{2}\\
		& $(\forall i\in [1,5]. \langle\textbf{true}*. idling(i)\rangle\top )
		\wedge$ & & & \\
		& $[ \textbf{true}^*] \forall i\in [1,5]. [ idling(i) ] \nu Y. \langle idling(i)\rangle Y$ &  & & \\ \hline
		
		\multirow{4}{*}{$\varphi_6$} & \textit{The lift may stop at Levels 2,3 and 4 for landing calls when travelling upwards}& \multirow{4}{*}{$32/0$} & \multirow{4}{*}{443352} & \multirow{4}{*}{2}\\
		& $\forall i \in [2,4].(\langle (\neg \textit{liftButton}(i))^*. \textit{direction}(\textit{up}).$ & & &\\
		&\ \ \  $ (\neg (\textit{liftButton}(i) + \textit{direction}(\textit{down})  ))^*. \textit{open}(i)\rangle\top
		)
		$ &  & & \\ \hline
		
		\multirow{4}{*}{$\varphi_7$} & \textit{The lift may stop at Levels 2,3 and 4 for landing calls when travelling downwards}& \multirow{4}{*}{$32/0$} & \multirow{4}{*}{443012} & \multirow{4}{*}{2}\\
		& $\forall i \in [2,4].
		(
		\langle (\neg \textit{liftButton}(i))^*. \textit{direction}(\textit{down}).$ & & &\\
		&\ \ \ $ (\neg (\textit{liftButton}(i) + \textit{direction}(\textit{up})  ))^*. \textit{open}(i)\rangle\top
		)$ &  & & \\ \hline
	\end{tabularx}
	\caption{Elevator properties with their partitioning and the size of the resulting VPG. In the \textbf{t}/\textbf{f} columns the first number shows for how many products the property holds. Columns $n$ and $d$ shows the number of vertices and distinct priorities in the resulting VPG.}
	\label{tab_elevator_formulas}
\end{table}
\subsection{Random games}
We create a set of random VPGs such that some games are very similar to the VPGs originating from the SPL verification problems and some games are very different. We use these games to further evaluate the performance of the algorithms.

The guard sets in the minepump and elevator games have a very specific distribution where nearly all of the sets admit either $100\%$ or $50\%$ of the configurations. This is because an edge requiring the presence or absence of one specific feature results in a set admitting $50\%$. On average the edges in the examples admit $92\%$ of the configurations. Most likely VPGs originating from FTSs will have such a distribution.

Random VPGs can be created by creating a random parity game and creating sets of configurations that guard the edges. For these sets we need to consider two factors: how large are the sets guarding the edges and how are they constructed.

We use $\lambda$ to denote the average relative size of guard sets in a VPG. So for every guard set in a VPG we divide its size by the total number of configurations to get the relative size of the guard set. Taking the average of all these relative sizes calculates $\lambda$.

For every random game we create, we pick a specific $\lambda$. This allows us to create games that have a $\lambda$ similar to those observed in the minepump and elevator example, i.e. $\lambda = 0.92$, and games that have a $\lambda$ very different from the SPL games.

Once we decided a value for $\lambda$ we need to decide the sizes of the individual guard set. We do so by using a probabilistic distribution ranging from $0$ to $1$ with a mean equal to $\lambda$. We consider two distributions, namely a modified Bernoulli distribution which creates guard sets of only relative size $0.5$ and $1$ and a beta distribution which creates guard sets with a more varying range of relative sizes. We can use the former to create random games that are similar to the SPL games and use the latter to create random games that are different to the SPL games.
\begin{itemize}
	\item A modified Bernoulli distribution; in a Bernoulli distribution there is a probability of $p$ to get an outcome of $1$ and a probability of $1-p$ to get an outcome of $0$. We modify this such that there is a probability of $p$ to get $1$ and a probability of $1-p$ to get $0.5$. This gives a mean of $1p + 0.5(1-p) = 0.5p + 0.5$. So to get a mean of $\lambda$ we choose $p = 2\lambda - 1$. Note that we cannot use this distribution when $\lambda < 0.5$ because $p$ becomes less than $0$.
	\item A beta distribution; a beta distribution ranges from $0$ to $1$ and is curved such that it has a specific mean. The beta distribution has two parameters: $\alpha$ and $\beta$ and a mean of $\frac{\alpha}{\alpha+\beta}$. We pick $\beta=1$ and $\alpha = \frac{\lambda\beta}{1-\lambda}$ to get a mean of $\lambda$.
\end{itemize}

Figures \ref{fig:dist_lambda50}, \ref{fig:dist_lambda75} and \ref{fig:dist_lambda90} show the shapes of the distribution for different values for $\lambda$.
\begin{figure}[H]
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.9]
		\begin{axis}[ytick=\empty,height=5cm,width=8cm]
		\addplot[color=blue,line width=1pt] coordinates 
		{(0.01,0)(0.02,0)(0.03,0)(0.04,0)(0.05,0)(0.06,0)(0.07,0)(0.08,0)(0.09,0)(0.1,0)(0.11,0)(0.12,0)(0.13,0)(0.14,0)(0.15,0)(0.16,0)(0.17,0)(0.18,0)(0.19,0)(0.2,0)(0.21,0)(0.22,0)(0.23,0)(0.24,0)(0.25,0)(0.26,0)(0.27,0)(0.28,0)(0.29,0)(0.3,0)(0.31,0)(0.32,0)(0.33,0)(0.34,0)(0.35,0)(0.36,0)(0.37,0)(0.38,0)(0.39,0)(0.4,0)(0.41,0)(0.42,0)(0.43,0)(0.44,0)(0.45,0)(0.46,0)(0.47,0)(0.48,0)(0.499999999,0)(0.5,1)(0.500000001,0)(0.52,0)(0.53,0)(0.54,0)(0.55,0)(0.56,0)(0.57,0)(0.58,0)(0.59,0)(0.6,0)(0.61,0)(0.62,0)(0.63,0)(0.64,0)(0.65,0)(0.66,0)(0.67,0)(0.68,0)(0.69,0)(0.7,0)(0.71,0)(0.72,0)(0.73,0)(0.74,0)(0.75,0)(0.76,0)(0.77,0)(0.78,0)(0.79,0)(0.8,0)(0.81,0)(0.82,0)(0.83,0)(0.84,0)(0.85,0)(0.86,0)(0.87,0)(0.88,0)(0.89,0)(0.9,0)(0.91,0)(0.92,0)(0.93,0)(0.94,0)(0.95,0)(0.96,0)(0.97,0)(0.98,0)(0.9999999,0)(1,0)(1.00001,0)};
		\end{axis}
		\end{tikzpicture}
		\caption{Modified Bernoulli distribution with $p=0$}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.9]
		\begin{axis}[ytick=\empty,height=5cm,width=8cm]
		\addplot[color=blue,line width=1pt] coordinates 
		{(0.01,1)(0.02,1)(0.03,1)(0.04,1)(0.05,1)(0.06,1)(0.07,1)(0.08,1)(0.09,1)(0.1,1)(0.11,1)(0.12,1)(0.13,1)(0.14,1)(0.15,1)(0.16,1)(0.17,1)(0.18,1)(0.19,1)(0.2,1)(0.21,1)(0.22,1)(0.23,1)(0.24,1)(0.25,1)(0.26,1)(0.27,1)(0.28,1)(0.29,1)(0.3,1)(0.31,1)(0.32,1)(0.33,1)(0.34,1)(0.35,1)(0.36,1)(0.37,1)(0.38,1)(0.39,1)(0.4,1)(0.41,1)(0.42,1)(0.43,1)(0.44,1)(0.45,1)(0.46,1)(0.47,1)(0.48,1)(0.49,1)(0.5,1)(0.51,1)(0.52,1)(0.53,1)(0.54,1)(0.55,1)(0.56,1)(0.57,1)(0.58,1)(0.59,1)(0.6,1)(0.61,1)(0.62,1)(0.63,1)(0.64,1)(0.65,1)(0.66,1)(0.67,1)(0.68,1)(0.69,1)(0.7,1)(0.71,1)(0.72,1)(0.73,1)(0.74,1)(0.75,1)(0.76,1)(0.77,1)(0.78,1)(0.79,1)(0.8,1)(0.81,1)(0.82,1)(0.83,1)(0.84,1)(0.85,1)(0.86,1)(0.87,1)(0.88,1)(0.89,1)(0.9,1)(0.91,1)(0.92,1)(0.93,1)(0.94,1)(0.95,1)(0.96,1)(0.97,1)(0.98,1)(0.99,1)(1,1)};
		\end{axis}
		\end{tikzpicture}
		\caption{Beta distribution with $\beta=1$ and $\alpha=1$}
	\end{subfigure}
	\caption{Edge guard size distribution for $\lambda = 0.5$}
	\label{fig:dist_lambda50}
\end{figure}%
\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
	\centering
	\begin{tikzpicture}[scale=0.9]
	\begin{axis}[ytick=\empty,height=5cm,width=8cm]
	\addplot[color=blue,line width=1pt] coordinates 
	{(0.01,0)(0.02,0)(0.03,0)(0.04,0)(0.05,0)(0.06,0)(0.07,0)(0.08,0)(0.09,0)(0.1,0)(0.11,0)(0.12,0)(0.13,0)(0.14,0)(0.15,0)(0.16,0)(0.17,0)(0.18,0)(0.19,0)(0.2,0)(0.21,0)(0.22,0)(0.23,0)(0.24,0)(0.25,0)(0.26,0)(0.27,0)(0.28,0)(0.29,0)(0.3,0)(0.31,0)(0.32,0)(0.33,0)(0.34,0)(0.35,0)(0.36,0)(0.37,0)(0.38,0)(0.39,0)(0.4,0)(0.41,0)(0.42,0)(0.43,0)(0.44,0)(0.45,0)(0.46,0)(0.47,0)(0.48,0)(0.499999999,0)(0.5,0.5)(0.500000001,0)(0.52,0)(0.53,0)(0.54,0)(0.55,0)(0.56,0)(0.57,0)(0.58,0)(0.59,0)(0.6,0)(0.61,0)(0.62,0)(0.63,0)(0.64,0)(0.65,0)(0.66,0)(0.67,0)(0.68,0)(0.69,0)(0.7,0)(0.71,0)(0.72,0)(0.73,0)(0.74,0)(0.75,0)(0.76,0)(0.77,0)(0.78,0)(0.79,0)(0.8,0)(0.81,0)(0.82,0)(0.83,0)(0.84,0)(0.85,0)(0.86,0)(0.87,0)(0.88,0)(0.89,0)(0.9,0)(0.91,0)(0.92,0)(0.93,0)(0.94,0)(0.95,0)(0.96,0)(0.97,0)(0.98,0)(0.9999999,0)(1,0.5)(1.00001,0)};
	\end{axis}
	\end{tikzpicture}
	\caption{Modified Bernoulli distribution with $p=0.5$}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
	\centering
	\begin{tikzpicture}[scale=0.9]
	\begin{axis}[ytick=\empty,height=5cm,width=8cm]
	\addplot[color=blue,line width=1pt] coordinates 
	{(0.01,0.0003)(0.02,0.0012)(0.03,0.0027)(0.04,0.0048)(0.05,0.0075)(0.06,0.0108)(0.07,0.0147)(0.08,0.0192)(0.09,0.0243)(0.1,0.03)(0.11,0.0363)(0.12,0.0432)(0.13,0.0507)(0.14,0.0588)(0.15,0.0675)(0.16,0.0768)(0.17,0.0867)(0.18,0.0972)(0.19,0.1083)(0.2,0.12)(0.21,0.1323)(0.22,0.1452)(0.23,0.1587)(0.24,0.1728)(0.25,0.1875)(0.26,0.2028)(0.27,0.2187)(0.28,0.2352)(0.29,0.2523)(0.3,0.27)(0.31,0.2883)(0.32,0.3072)(0.33,0.3267)(0.34,0.3468)(0.35,0.3675)(0.36,0.3888)(0.37,0.4107)(0.38,0.4332)(0.39,0.4563)(0.4,0.48)(0.41,0.5043)(0.42,0.5292)(0.43,0.5547)(0.44,0.5808)(0.45,0.6075)(0.46,0.6348)(0.47,0.6627)(0.48,0.6912)(0.49,0.7203)(0.5,0.75)(0.51,0.7803)(0.52,0.8112)(0.53,0.8427)(0.54,0.8748)(0.55,0.9075)(0.56,0.9408)(0.57,0.9747)(0.58,1.0092)(0.59,1.0443)(0.6,1.08)(0.61,1.1163)(0.62,1.1532)(0.63,1.1907)(0.64,1.2288)(0.65,1.2675)(0.66,1.3068)(0.67,1.3467)(0.68,1.3872)(0.69,1.4283)(0.7,1.47)(0.71,1.5123)(0.72,1.5552)(0.73,1.5987)(0.74,1.6428)(0.75,1.6875)(0.76,1.7328)(0.77,1.7787)(0.78,1.8252)(0.79,1.8723)(0.8,1.92)(0.81,1.9683)(0.82,2.0172)(0.83,2.0667)(0.84,2.1168)(0.85,2.1675)(0.86,2.2188)(0.87,2.2707)(0.88,2.3232)(0.89,2.3763)(0.9,2.43)(0.91,2.4843)(0.92,2.5392)(0.93,2.5947)(0.94,2.6508)(0.95,2.7075)(0.96,2.7648)(0.97,2.8227)(0.98,2.8812)(0.99,2.9403)(1,3)};
	\end{axis}
	\end{tikzpicture}
	\caption{Beta distribution with $\beta=1$ and $\alpha=3$}
\end{subfigure}
\caption{Edge guard size distribution for $\lambda = 0.75$}
\label{fig:dist_lambda75}
\end{figure}%
\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
	\centering
	\begin{tikzpicture}[scale=0.9]
	\begin{axis}[ytick=\empty,height=5cm,width=8cm]
	\addplot[color=blue,line width=1pt] coordinates 
	{(0.01,0)(0.02,0)(0.03,0)(0.04,0)(0.05,0)(0.06,0)(0.07,0)(0.08,0)(0.09,0)(0.1,0)(0.11,0)(0.12,0)(0.13,0)(0.14,0)(0.15,0)(0.16,0)(0.17,0)(0.18,0)(0.19,0)(0.2,0)(0.21,0)(0.22,0)(0.23,0)(0.24,0)(0.25,0)(0.26,0)(0.27,0)(0.28,0)(0.29,0)(0.3,0)(0.31,0)(0.32,0)(0.33,0)(0.34,0)(0.35,0)(0.36,0)(0.37,0)(0.38,0)(0.39,0)(0.4,0)(0.41,0)(0.42,0)(0.43,0)(0.44,0)(0.45,0)(0.46,0)(0.47,0)(0.48,0)(0.499999999,0)(0.5,0.2)(0.500000001,0)(0.52,0)(0.53,0)(0.54,0)(0.55,0)(0.56,0)(0.57,0)(0.58,0)(0.59,0)(0.6,0)(0.61,0)(0.62,0)(0.63,0)(0.64,0)(0.65,0)(0.66,0)(0.67,0)(0.68,0)(0.69,0)(0.7,0)(0.71,0)(0.72,0)(0.73,0)(0.74,0)(0.75,0)(0.76,0)(0.77,0)(0.78,0)(0.79,0)(0.8,0)(0.81,0)(0.82,0)(0.83,0)(0.84,0)(0.85,0)(0.86,0)(0.87,0)(0.88,0)(0.89,0)(0.9,0)(0.91,0)(0.92,0)(0.93,0)(0.94,0)(0.95,0)(0.96,0)(0.97,0)(0.98,0)(0.9999999,0)(1,0.8)(1.00001,0)};
	\end{axis}
	\end{tikzpicture}
	\caption{Modified Bernoulli distribution with $p=0.8$}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
	\centering
	\begin{tikzpicture}[scale=0.9]
	\begin{axis}[ytick=\empty,height=5cm,width=8cm]
	\addplot[color=blue,line width=1pt] coordinates 
	{(0.01,8.99999999999993E-16)(0.02,2.30399999999998E-13)(0.03,5.90489999999996E-12)(0.04,5.89823999999997E-11)(0.05,3.51562499999998E-10)(0.06,1.51165439999999E-09)(0.07,5.18832089999997E-09)(0.08,1.50994943999999E-08)(0.09,3.87420488999998E-08)(0.1,8.99999999999996E-08)(0.11,1.92922992899999E-07)(0.12,3.86983526399999E-07)(0.13,7.34157648899998E-07)(0.14,1.3282101504E-06)(0.15,2.3066015625E-06)(0.16,3.86547056639999E-06)(0.17,6.27818169689999E-06)(0.18,9.91796451839998E-06)(0.19,1.52852067369E-05)(0.2,2.30399999999999E-05)(0.21,3.40405734248999E-05)(0.22,4.93882861823999E-05)(0.23,7.04798867528999E-05)(0.24,9.90677827583998E-05)(0.25,0.000137329101563)(0.26,0.000187944358118)(0.27,0.000254186582833)(0.28,0.000340021798502)(0.29,0.000450221771665)(0.3,0.00059049)(0.31,0.000767601933697)(0.32,0.000989560464998)(0.33,0.001265767756417)(0.34,0.001607214514406)(0.35,0.002026687851563)(0.36,0.00253899891671)(0.37,0.003161231508529)(0.38,0.003913012924646)(0.39,0.004816808334433)(0.4,0.00589824)(0.41,0.007186432706209)(0.42,0.008714386796774)(0.43,0.010519380249841)(0.44,0.012643401262694)(0.45,0.015133612851563)(0.46,0.018042851008742)(0.47,0.021430157995585)(0.48,0.02536135238615)(0.49,0.029909637512641)(0.5,0.03515625)(0.51,0.041191150113361)(0.52,0.04811375567831)(0.53,0.056033721370225)(0.54,0.065071765205222)(0.55,0.075360544101563)(0.56,0.087045580416614)(0.57,0.100286241400801)(0.58,0.115256773546214)(0.59,0.132147393843889)(0.6,0.15116544)(0.61,0.172536581697553)(0.62,0.196506095026406)(0.63,0.223340202240769)(0.64,0.25332747903959)(0.65,0.286780331601562)(0.66,0.324036545642726)(0.67,0.365460909800977)(0.68,0.411446915688039)(0.69,0.462418536985777)(0.7,0.51883209)(0.71,0.581178178121185)(0.72,0.649983722677862)(0.73,0.725814082704672)(0.74,0.809275266183398)(0.75,0.901016235351562)(0.76,1.00173130870948)(0.77,1.11216266239291)(0.78,1.23310293361482)(0.79,1.36539792891591)(0.8,1.50994944)(0.81,1.66771816996666)(0.82,1.83972677278948)(0.83,2.02706300892514)(0.84,2.23088301997425)(0.85,2.45241472535156)(0.86,2.69296134395927)(0.87,2.95390504389341)(0.88,3.23671072324977)(0.89,3.54292992513187)(0.9,3.87420489)(0.91,4.23227274853637)(0.92,4.61896985823806)(0.93,5.03623628698536)(0.94,5.48612044686974)(0.95,5.97078388160157)(0.96,6.49250621085451)(0.97,7.05369023493927)(0.98,7.65686720323607)(0.99,8.30470224985128)(1,9)};
	\end{axis}
	\end{tikzpicture}
	\caption{Beta distribution with $\beta=1$ and $\alpha=9$}
\end{subfigure}
\caption{Edge guard size distribution for $\lambda = 0.9$}
\label{fig:dist_lambda90}
\end{figure}

Consider the creation of a random game that has $2^m$ configurations, some $\lambda$ is decided upon and one of the above distribution is chosen. For an individual guard set we use the random distribution to decide how large this guard set should be. Consider the creation of a specific guard set and let $r$ denote the relative size of this guard set, decided using the random distribution we chose.

We now need to consider how to create a guard set of relative size $r$. We can simply create a random set of configurations without any notion of features; we call this a \textit{configuration based} approach. Using this approach we can easily create a guard set of relative size $r$ by simply picking $\lfloor 2^m*r\rfloor$ configurations randomly.

Alternatively we can use a \textit{feature based} approach where we create sets by looking at features. Consider features $f_0, \dots, f_m$, we can create a boolean function that is the conjunction of $k$ features where every feature in the conjunction has probability $\frac{1}{2}$ of being negated.  For example when using $k=3$ and $m=5$ we might get boolean formula $f_1 \wedge \neg f_2 \wedge \neg f_4$. Such a boolean formula corresponds to a set of configurations of size $2^{m-k}$ and a relative size $\frac{2^{m-k}}{2^m} = 2^{-k}$. Since we are creating a set of relative size $r$, we choose $k = \min(m, \lfloor -\log_2{r} \rfloor)$. When using a feature based approach we can only create sets that have a relative size of $2^{-i}$ for some $i \in \mathbb{N}$.

When creating a random game for some $\lambda$ we have considered how we can choose the size of individual set sizes and how to construct sets of that size. This gives us four different ways to construct games:
\begin{enumerate}
	\item Bernoulli distributed and feature based. These games are most similar to the SPL games.
	\item Bernoulli distributed and configuration based. These games do have the characteristics of an SPL game in terms of set size but have unstructured sets guarding the edges. Furthermore with a configuration based approach fewer guard sets will be identical than with a feature based approach.
	\item Beta distributed and configuration based. These games are most different from the SPL games.
	\item Beta distributed and feature based. Using a feature based approach we can only create sets of size $2^{-i}$ for any $\lambda \geq \frac{1}{2}$. So using a beta distribution we must round to such a size. Almost all the sets will get a relative size of either $\frac{1}{2}$ or $1$. So this creates almost the exact same games as using the Bernoulli distribution, therefore we will not consider this category of games.
\end{enumerate}

We create four sets of random games. For random games of type 1,2 and 3 we create 25 games: game 75 to game 99, where game $i$ has $\lambda=\frac{i}{100}$ and a random number of features, nodes, edges and maximum priority. Furthermore we create 52 games to evaluate how the algorithm scales when the number of features becomes larger. For every $i \in [2,15]$ we create random games $i$, $i.25$, $i.50$ and $i.75$ of type 1 with $\lambda=0.92$, $\lfloor i\rfloor$ features and a random number of nodes, edges and maximum priority. 

Besides the number of configurations and the value for $\lambda$ we need to choose the number of vertices for a game, the minimum number of successors of a vertex, the maximum number of successors of a vertex and the number of distinct priorities in the game. The number of minimum and maximum successor is decided per game. So if we pick $l$ and $h$ as the number of minimum and maximum then for every vertex in the game we uniformly pick its number of successors between $l$ and $h$.

Table \ref{tab_random_games} shows the different categories of games and the corresponding parameters. The minimum number of successors per vertex is always 1 so this value is omitted from the table. The games that scale in $\lambda$ share the same random configuration per game number. So game $i$ of type 1 that scales in $\lambda$ has the same number of vertices, maximum successors, distinct priorities and configurations as game $i$ of type 2 and 3 that scale in $\lambda$.

\begin{table}
\centering
	\begin{tabular}{|l|l|l|l|l|l|}
		\hline
		Category & \# vertices & \shortstack{Maximum \\\# successors} & \shortstack{\# distinct\\priorities} & \# confs  & $\lambda$ \\ \hline
		Type 1, scale in $\lambda$ & & & & & \\ \cline{1-1}  
		Type 2, scale in $\lambda$ &$100-600$  & $3-20$                   & $1-10$                          & $2^{4}-2^{12}$ & $\frac{\textit{game nr}}{100}$            \\ \cline{1-1} 
		Type 3, scale in $\lambda$ & & & & & \\ \hline
		Type 1, scale in \# confs          & $100-600$            &  $3-20$                   & $1-10$                          & $2^\textit{game nr}$                & $0.92$                   \\ \hline
	\end{tabular}
\caption{Categories of random games}
	\label{tab_random_games}
\end{table}
