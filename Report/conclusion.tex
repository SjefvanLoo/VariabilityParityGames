An SPL can be verified using traditional model-checking techniques. These techniques check every product described in SPL independently. However, the number of products potentially scales exponentially in the number of features. So we could end up with a large number of products which makes independent checking undesirable. We have presented a method of model-checking an SPL, that models its behaviour using an FTS, such that commonalities between the different products are exploited to increase performance.

We extended parity games to express variability; these games are called variability parity games (VPGs). VPGs express variability through configurations; a VPG describes a parity game for every configuration. We have shown that we can construct a VPG from an FTS and modal $\mu$-calculus formula such that solving the FTS gives the information needed to decide which products satisfy the formula. VPGs can be solved independently where we solve every parity game described by the VPG. However, this is similar to independently model-checking all the products in the SPL. We introduced several collective algorithms that solve a VPG as a whole and try to exploit commonalities between the different configurations.

First we introduced a variant of Zielonka's recursive algorithm that solves VPGs. The algorithm views a VPG as a collection of parity games; a parity game for every configuration. We can represent such a collection with a single game graph and for every vertex and edge we have a set of configurations indicating if this vertex or edge is part of the parity game of that configuration. We modified the recursive algorithm to use such a representation. Specifically, we modified the attractor algorithm to try and attract multiple configurations per vertex at the same time. This modified attractor algorithm relies heavily on set operations over the sets of configurations associated with the vertices and edges. These sets can be either represented symbolically or explicitly, giving two variants of the recursive algorithm for VPGs.

Next we introduced the incremental pre-solve algorithm for VPGs. This algorithm tries to find vertices that are won by one of the players for all configurations, if such a vertex is found it is said to be pre-solved. The algorithm tries to find these vertices and then splits the configurations in two sets and goes into recursion for both of them. In the recursion the configuration set has decreased in size so potentially more vertices can be pre-solved. The algorithm finds these vertices through solving pessimistic parity games. Pessimistic parity games are created from a VPG and for a player $\alpha$, they have the property that any vertex won by player $\alpha$ is also won by player $\alpha$ in the VPG played for any configuration. The incremental pre-solve algorithm creates two pessimistic parity games (for player 0 and 1) and solves them using the fixed-point iteration algorithm. The fixed-point algorithm is modified to use vertices that already were pre-solved to increase its performance. The algorithm incrementally builds up the set of pre-solved vertices until either all vertices are pre-solved or a single configuration remains. In the worst case the algorithm solves linearly more (pessimistic) parity game than we would using an independent approach. However by increasing the number of pre-solved vertices the algorithm tries to outperform the independent approach by solving the (pessimistic) parity games increasingly quicker.

We introduced local variants of the recursive algorithm for parity games and the fixed-point algorithm for parity games. A local parity game algorithm tries to only determine the winner of a single vertex instead of all the vertices, potentially increasing its performance. We also introduced local variants of the collective algorithms mentioned above.

The incremental pre-solve algorithm has the same time complexity as independently solving a VPG using the fixed-point iteration algorithm. The recursive algorithms for VPGs have a worse worst-case time complexity than independently solving a VPG using the recursive algorithm for parity games. However, the aim of the algorithms is to solve VPGs originating from FTSs efficiently. Often times these VPGs will have a lot of commonalities between the configurations. The algorithms are implemented and their actual performance is compared to independent approaches. The minepump and elevator SPLs are used to evaluate the performances. Furthermore a collection of random games is created with different characteristics ranging from very similar to VPGs originating from SPLs to completely different from VPGs originating from SPLs.

We observed that for the SPL VPGs and random VPGs created to be similar to SPL VPGs the symbolic variant of the incremental pre-solve algorithm performs best. The incremental pre-solve algorithm generally also outperforms its independent counterpart, i.e. independently solving a VPG using the fixed-point iteration algorithm. However, for the SPL VPGs, it does so less significantly and consistently than the symbolic recursive algorithm does. It also scales poorer in the number of features than the symbolic recursive algorithm does. Furthermore the independent approach using the recursive algorithm greatly outperforms the independent approach using the fixed-point algorithm. Because the incremental pre-solve algorithm uses the fixed-point algorithm its absolute performance is significantly worse than the recursive algorithm.

We observed the explicit recursive variant to perform either very similar or better than the independent approach across all games considered. From this we conclude that, even when VPGs are less similar to the SPL VPGs, there is room to exploit commonalities and in some cases increase performance without running the risk of significantly decreasing performance. Whether there are types of VPGs for which the explicit algorithm would perform significantly worse that the independent approach is left unanswered.

Notably, the difference between the local and global variants of the recursive algorithms for VPGs is very little. However, the difference between the local and global variant of the incremental pre-solve algorithm is very large across most types of VPGs. Furthermore, the local variant of the incremental pre-solve algorithm does seem to scale well in the number of features. This that local algorithms for VPGs can greatly increase performance compared to global algorithms, more so that locally solving parity games increases performance compared to globally solving parity games.

\paragraph{Future work} Even though the incremental pre-solve algorithms performance was not the best, it did in average outperform its independent counterpart. Therefore it would be interesting to study the incremental pre-solve algorithm using a different way of solving pessimistic parity games; for example, using a variant of the recursive algorithm that can work with pre-solved vertices. This would potentially yield an algorithm that is more \textit{robust}  than the symbolic recursive algorithm in the sense that it performs well across different VPGs and not only for VPGs that originate from SPLs. Note that the local variant of the incremental pre-solve algorithm terminates early when the vertex we are looking for is pre-solved. This does not depend on the parity game algorithm that is used to solve pessimistic parity games. So the increase in performance of the local incremental pre-solve compared to the global incremental pre-solve variant will, most likely, still be observed when using a different parity game algorithm to sole the (pessimistic) parity games.

Furthermore, many optimizations are known for solving parity games. It would be interesting to study if these improvements are applicable to VPGs and if they increase the performance of VPG solving more than they increase the performance of parity game solving. 

Finally, the creation of VPGs is left unstudied in this thesis, it would be interesting to study how one could efficiently create VPGs from FTSs including the creation of BDDs.