In the previous section we have seen a local variant of Zielonka's recursive algorithm for parity games that uses $\Delta \subseteq \{0,1\}$ to indicate for which player we are trying to find the specific vertex.

Consider VPG $\hat{G}$ with configuration set $\mathfrak{C}$ and origin vertex $\hat{v}_0$ which we are trying to solve locally. Unified parity game $\hat{G}_{\downarrow}$ contains vertices $\mathfrak{C} \times \{\hat{v}_0\}$. If we find the winning player for each of these vertices we have solved the VPG locally. We are going to solve a unified parity game locally, but instead of finding the winner of a single vertex we are finding the winners for a set of vertices, specifically vertices: $\mathfrak{C} \times \{\hat{v}_0\}$.

When we locally solve a parity game using the recursive algorithm we can sometimes avoid the second recursion because we already found the winner of $\hat{v}_0$. However when locally solving a unified parity game we might find $\hat{v}_0$ for some configuration but not for all. When we find $\hat{v}_0$ to be won by player $\overline{\alpha} \in \Delta$ for configurations $C \subseteq \mathfrak{C}$ then we remove all vertices with configurations $C$ from the game, i.e. we remove vertices $C \times \hat{V}$. For the remaining vertices we do go into the second recursion. Pseudo code is presented in Algorithm \ref{alg_zlnk_collective_local}; we introduce function $\textsc{LocalConfs}$ which returns the configurations for which we have found the local solution.

The algorithm uses definitions to reason about projections of unified parity games and sets to configuration(s). Previously we introduced a simple projection definition that projects a unified parity game to a configuration (Definition \ref{def_vpg_proj}). This is possible because vertices in a unified parity game consist of pairs of configurations and origin vertices. We define a similar projection for sets of vertices consisting of pairs of configurations and origin vertices.
\begin{definition}
	Given set $X \subseteq (\mathfrak{C} \times \hat{V})$ we define the projection of $X$ to $c \in \mathfrak{C}$, denoted by $X_{|c}$, as
	\[ X_{|c} = \{ \hat{v}\ |\ (c,\hat{v}) \in X \} \]
\end{definition}
Furthermore we need to be able to reason about projections not only to a single vertex but to a group of vertices. 
\begin{definition}
	Given set $X \subseteq (\mathfrak{C} \times \hat{V})$ we define the projection of $X$ to $C \subseteq \mathfrak{C}$, denoted by $X_{||C}$, as
	\[ X_{||C} = X \cap (C \times \hat{V}) \]
\end{definition}

\begin{algorithm}
	\caption{$\textsc{RecursiveUPGLocal}(\textit{parity game } G = (\\
		V \subseteq \mathfrak{C} \times \hat{V},\\
		\hat{V}_0 \subseteq \hat{V},\\
		\hat{V}_1 \subseteq \hat{V},\\
		E \subseteq (\mathfrak{C} \times \hat{V}) \times (\mathfrak{C} \times \hat{V}),\\
		\hat{\Omega} : \hat{V} \rightarrow \mathbb{N}),\\
		\hat{v}_0 \in \hat{V},\\
		\Delta \subseteq \{ 0,1\})$}
	\label{alg_zlnk_collective_local}
	\begin{multicols}{2}
		\begin{algorithmic}[1]
			\If{$V = \emptyset$}
			\State \Return $(\emptyset,\emptyset)$
			\EndIf
			\State $h \gets\max\{ \hat{\Omega}(\hat{v})\ |\ (c,\hat{v}) \in V\}$
			\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
			\State $U \gets \{(c,\hat{v}) \in V\ |\ \hat{\Omega}(\hat{v}) = h\}$
			\State $A \gets \alpha\textit{-Attr}(G, U)$
			\If{$\overline{\alpha} \in \Delta$}
			\State $(W_0', W_1') \gets \textsc{RecursiveUPGLocal}(G \backslash A,\hat{v}_0,\{\overline{\alpha}\})$
			\Else
			\State $(W_0', W_1') \gets \textsc{RecursiveUPGLocal}(G \backslash A,\hat{v}_0,\emptyset)$
			\EndIf
			\If{$W_{\overline{\alpha}}' =\emptyset$}\label{line:recursiveUPGLocal:wopponentisempty}
			\State $W_\alpha \gets A \cup W_\alpha'$
			\State $W_{\overline{\alpha}} \gets \emptyset$
			\Else
				\State $B \gets \overline{\alpha}\textit{-Attr}(G, W'_{\overline{\alpha}})$\label{line:recursiveUPGLocal:calcB}
				\State $C_B \gets \textsc{LocalConfs}(B)$\label{line:recursiveUPGLocal:calcC_B}
				\State $(W_0'', W_1'') \gets \textsc{RecursiveUPGLocal}(G \backslash B\backslash (V_{||C_B}), \hat{v}_0, \Delta)$\label{line:recursiveUPGLocal:subgame2}
				\State $W_\alpha \gets W''_\alpha$
				\State $W_{\overline{\alpha}} \gets W''_{\overline{\alpha}} \cup B$
			\EndIf
			\State \Return $(W_0, W_1)$
		\end{algorithmic}\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip
		\begin{algorithmic}[1]
			\Function{LocalConfs}{$X \subseteq V$}
			\If{$\overline{\alpha} \in \Delta$}
				\State \Return $\{ c \in \mathfrak{C}\ |\ (c, \hat{v}_0) \in X \}$
			\Else
				\State \Return $\emptyset$
			\EndIf
			\EndFunction
		\end{algorithmic}
	\end{multicols}
\end{algorithm}

We prove the correctness of Algorithm \ref{alg_zlnk_collective_local} by showing that every projection of the unified parity game is either solved globally or locally. We first prove the following auxiliary lemma to reason about projections.

\begin{lemma}
	\label{lem_projected_attr_is_attr_of_projected}
	Given unified parity game $G = (V,\hat{V}_0,\hat{V}_1,E,\hat{\Omega})$, configuration $c \in \mathfrak{C}$ and non-empty set $X \subseteq (\mathfrak{C} \times \hat{V})$ such that $X_{|c} \neq \emptyset$, it holds that $\alpha$-Attr$(G,X)_{|c}= \alpha$-Attr$(G_{|c},X_{|c})$.
	\begin{proof}
		This lemma follows immediately from the fact that a unified parity game is the union of its projections. Furthermore, edges in unified parity games do not cross configurations, i.e. for any $((c,v),(c',v')) \in E$ we get $c = c'$.
	\end{proof}
\end{lemma}

Next we prove the correctness. \ We prove that either the projection onto a configuration is solved globally by the algorithm or in the projection $\hat{v}_0$ is found to be winning for player $\beta \in \Delta$. This is very similar to the local recursive algorithm for parity games (Algorithm \ref{alg_zlnk_local} and Theorem \ref{the_local_zlnk_correct}) where we proved these similar properties.
\begin{theorem}
	Given:
	\begin{itemize}
		\item VPG $\hat{G} = (\hat{V}, \hat{V}_0,\hat{V}_1,\hat{E},\hat{\Omega},\mathfrak{C},\theta)$,
		\item origin vertex $\hat{v}_0 \in \hat{V}$,
		\item total unified parity game $G = (V, \hat{V}_0, \hat{V}_1,E,\hat{\Omega})$ that is a subgame of, or equal to, unified parity game $\hat{G}_{\downarrow}$,
		\item configuration $c\in \mathfrak{C}$,
		\item winning sets $(Q_0,Q_1)$ for game $G_{|c}$,
		\item a set of players $\Delta \subseteq \{0,1\}$ and
		\item winning sets $(W_0, W_1) = \textsc{RecursiveUPGLocal}(G,\hat{v}_0,\Delta)$
	\end{itemize}
	at least one of the following statements hold:
	\begin{enumerate}[(I)]
		\item For some $\beta \in \Delta$ we have $(c,\hat{v}_0) \in W_\beta$, $(W_0)_{|c} \subseteq Q_0$ and $(W_1)_{|c} \subseteq Q_1$.
		\item $(W_0)_{|c} = Q_0$ and $(W_1)_{|c} = Q_1$.
	\end{enumerate}
	\begin{proof}
		Proof by induction on $G$.
		
		\textbf{Base}: If $G$ is empty then the algorithm returns $(\emptyset,\emptyset)$ in which case statement (II) holds trivially.
		
		\textbf{Step}:
		When $G_{|c}$ is empty then $(W_0)_{|c} = \emptyset$ and $(W_0)_{|c} = \emptyset$ because the algorithm only returns vertices in the winning sets that are in $V$. In this case statement (II) holds trivially. Assume for the remainder of the proof that $G_{|c}$ is not empty, that is $V_{|c} \neq \emptyset$.
		
		The algorithm considers the highest priority in the game and assign the parity of this priority to $\alpha$. The set $U$ contains all vertices with this priority and $A$ contains all vertices from where player $\alpha$ can force the play into $U$.
		
		The first recursion removes vertices in $A$ from the game. Since $A$ is non-empty we can apply induction to find that at least one of the two statements hold for $G\backslash A$ and winning sets $(W_0',W_1')$.
		
		If $W'_{\overline{\alpha}} = \emptyset$ (line \ref{line:recursiveUPGLocal:wopponentisempty}) then no vertex is won by player $\overline{\alpha}$ in $G\backslash A$ and therefore no vertex in $(G\backslash A)_{|c}$ is won by player $\overline{\alpha}$. Therefore statement (II) holds for $G\backslash A$ and indeed all vertices in $(G\backslash A)_{|c}$ are won by player $\alpha$, moreover player $\alpha$ has a strategy $\sigma_\alpha$ for $(G\backslash A)_{|c}$ that is winning for all vertices. Clearly this strategy can also be applied in game $G_{|c}$. Consider valid path $\pi$ in game $G_{|c}$ conforming to $\sigma_\alpha$. When this path eventually stays in $(V \backslash A)_{|c}$ then player $\alpha$ wins because $\sigma_\alpha$ is winning here. Otherwise the path visits $A_{|c}$ infinitely often, in which case player $\alpha$ can force the play into $U_{|c}$ infinitely often and therefore the highest priority occurring infinitely often has parity $\alpha$. So player $\alpha$ wins all vertices in $V_{|c}$ and the algorithm returns winning sets accordingly; statement (II) holds.
		
		Otherwise the algorithm continues with calculating set $B$ (line \ref{line:recursiveUPGLocal:calcB}) and $C_B$ (line \ref{line:recursiveUPGLocal:calcC_B}).
		
		For the remainder of the proof numerous case distinction need to be made. These distinctions will be presented in a Fitch-like style to improve readability.
		
		First we distinguish two cases for $A_{|c}$.
		
		\begin{tabular}{|p{14.2cm}}
			Assume $A_{|c} = \emptyset$\\
			\hline
			Clearly $G_{|c} = (G\backslash A)_{|c}$, so all vertices in $(W'_{\overline{\alpha}})_{|c}$ are won by player $\overline{\alpha}$ in game $G_{|c}$.
		\end{tabular}\\\\
		\begin{tabular}{|p{14.2cm}}
			Assume $A_{|c} \neq \emptyset$\\
			\hline
			We use Lemma's \ref{lem_projected_attr_is_attr_of_projected} and \ref{lem_overlinealphawinner} to find that the vertices in $(W'_{\overline{\alpha}})_{|c}$ are won by player $\overline{\alpha}$ in $G_{|c}$.
		\end{tabular}\\\\
		In either case we find that all vertices in $(W'_{\overline{\alpha}})_{|c}$ are won by player $\overline{\alpha}$ in $G_{|c}$.
		
		\begin{longtable}{|p{14.2cm}}
				Assume $c \in C_B$\\
				\hline
				The second subgame that is created by the algorithm (line \ref{line:recursiveUPGLocal:subgame2}) does not contain any vertices with configuration $c$ because $V_{||C_B}$ is removed from the game. Therefore $W''_0$ and $W''_1$ do not contain any vertices with configuration $c$. We find that the only vertices with configuration $c$ that are returned by the algorithm are in the set $B$.\\
				For $c$ to be in $C_B$ we must have $(W'_{\overline{\alpha}})_{|c} \neq \emptyset$. We can apply Lemma \ref{lem_projected_attr_is_attr_of_projected} to find that set $B_{|c}$ contains all vertices such that player $\overline{\alpha}$ can force the play to $(W'_{\overline{\alpha}})_{|c}$ in game $G_{|c}$. Earlier we found that all vertices in $(W'_{\overline{\alpha}})_{|c}$ are won by player $\overline{\alpha}$ in game $G_{|c}$ so clearly all vertices in $B_{|c}$ are also won by player $\overline{\alpha}$.\\
				The algorithm returns vertices $B_{|c}$ to be winning for player $\overline{\alpha}$. Because $c \in C_B$ we find that $\overline{\alpha} \in \Delta$ and $\hat{v}_0 \in B_{|c}$. We conclude that statement (I) holds.
		\end{longtable}
		\begin{longtable}{|p{14.2cm}}
			Assume $c \notin C_B$\\
			\hline
			If statement (I) holds for $G\backslash A$ then we would have found $\overline{\alpha} \in \Delta$ and $\hat{v}_0 \in (W'_{\overline{\alpha}})_{|c}$. Because $(W'_{\overline{\alpha}})_{|c} \subseteq B_{|c}$ we would also found $c \in C_B$. Since this is not the case we find that statement (II) holds for $G\backslash A$.\\
			\begin{tabular}{|p{13.6cm}}
				Assume $(W'_{\overline{\alpha}})_{|c} = \emptyset$\\
				\hline
				In this case $B_{|c} = \emptyset$ and the second subgame $G'$ created (line \ref{line:recursiveUPGLocal:subgame2}) projected onto $c$ is identical to $G_{|c}$. Using induction we find that statement (I) or (II) hold for $G'$. The algorithm returns $W''_0$ and $W''_1$ for game $G'$ so the same statement that holds for the subgame holds for $G$. Note that $B$ does not contain vertices with configuration $c$.
			\end{tabular}\\\\
			\begin{tabular}{|p{13.6cm}}
				Assume $(W'_{\overline{\alpha}})_{|c} \neq \emptyset$\\
				\hline
				We apply Lemma \ref{lem_projected_attr_is_attr_of_projected} to find that $B_{|c} = \overline{\alpha}\textit{-Attr}(G_{|c},(W'_{\overline{\alpha}})_{|c})$. For the second subgame $G'$ created (line \ref{line:recursiveUPGLocal:subgame2}) we have $(G')_{|c} = G_{|c} \backslash B_{|c}$ because $V_{||C_B}$ contains no vertices with configuration $c$.\\
				The algorithm returns any vertex $\hat{v}$ in $(W''_\beta)_{|c}$ to be winning for player $\beta$ in game $G_{|c}$. Using induction and Lemma \ref{lem_GwithoutB_is_subset} we find that indeed $\hat{v}$ is won by player $\beta$ in game $G_{|c}$. Furthermore the algorithm returns $B_{|c}$ to be winning for player $\overline{\alpha}$. Earlier we found that all vertices in $(W'_{\overline{\alpha}})_{|c}$ are won by player $\overline{\alpha}$ in game $G_{|c}$, so clearly all vertices in $B_{|c}$ are also won by player $\overline{\alpha}$.\\
				The vertices with configuration $c$ that are returned by the algorithm are in the correct winning set. If statement (I) holds for the subgame $G'$ then statement (I) also holds for $G$ because we use $\Delta$ unmodified in the recursion. If statement (II) holds for the subgame $G'$ then statement (II) also holds for $G$.
			\end{tabular}
		\end{longtable}
	\end{proof}
\end{theorem}

The pseudo code presented for the algorithm uses a set-wise representation of unified parity games. As we have seen previously in the \textsc{RecursiveUPG} algorithm, we can modify the recursive algorithm to use a function-wise representation with a function-wise attractor set calculation. The \textsc{RecursiveUPGLocal} algorithm can be transformed in the same way. The \textsc{RecursiveUPGLocal} algorithm introduces a definition for projecting to sets of configurations as well as the \textsc{LocalConfs} subroutine. We introduce function-wise variants for this definition and subroutine.
\begin{definition}
	Given function $X : \hat{V} \rightarrow 2^\mathfrak{C}$ we define the projection of $X$ to $C \subseteq \mathfrak{C}$, denoted by $X_{||C}$, as
	\[ X_{||C}(\hat{v}) = X(\hat{v}) \cap C \]
\end{definition}
Algorithm \ref{alg_flobalconfs} shows a function wise implementation of the \textsc{LocalConfs} subroutine. It is trivial to see that this algorithm and the projection definition are equal under the $=_\lambda$ operator to their set-wise counterparts.
\begin{algorithm}
	\caption{Function-wise \textsc{LocalConfs} subroutine}
	\label{alg_flobalconfs}
	\begin{algorithmic}[1]
		\Function{FLocalConfs}{$X : \hat{V} \rightarrow 2^\mathfrak{C}$}
		\If{$\overline{\alpha} \in \Delta$}
		\State \Return $X(\hat{v}_0)$
		\Else
		\State \Return $\emptyset$
		\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

We can solve a VPG locally using this local recursive algorithm for unified parity games. We can either represent the parity games set-wise or we can present them function-wise, in which case we can represent the sets of configurations explicitly or symbolically. In all three cases the time complexities are identical to their global counterparts because in the worst case the vertex we are searching for is never won by player $\overline{\alpha} \in \Delta$ at any recursion level. Furthermore the added projection operations are subsumed in worst-case time complexity by the attractor set calculation so the worst-case time complexity argumentation presented for the global variants is also valid for the local variants. 