Model verification techniques can be used to improve the quality of software. These techniques require the behaviour of the software to be modelled and these models can then be checked to verify that they behave conforming to some formally specified requirement. These verification techniques are well-studied, specifically techniques to verify a single software product.

\textit{Software product lines} (SPLs) are systems that can be configured to result in different variants of the same system \cite{ClementsSoftwareProduct2001,SPLsFoundationAndTechniques}. SPLs describe \textit{families} of software products where the products originate from the same system and often times have a lot of commonalities. The difference between the products in a family is called the \textit{variability} of the family \cite{OnTheNotionOfVariability}. A family of products can be verified by using traditional verification techniques to verify every single product independently. However, verifying models is expensive in term of computing power and the number of products in an SPL can grow large, therefore having to verify every single product independently is undesirable \cite{CheckingLotsOfSystems}.

A common way of modelling the behaviour of software is by using \textit{labelled transition systems} (LTSs) \cite{Groote}. While LTSs can model behaviour well they cannot model variability. Efforts to also model variability include  modal transition systems \cite{ModalTS1,ModalTS2,ModalTS3}, I/O automata \cite{ModalIOAutomata,ModelCheckingDomainArtifacts} and \textit{featured transition systems} (FTSs) \cite{CheckingLotsOfSystems,FTSLTL}. Specifically the latter is well suited to model all the different behaviours of the software products as well as the variability of the entire system in a single model. FTSs use \textit{features} to express variability; a feature is an option that can be turned on or off for the system. In the context of FTSs, a set of features is synonymous with a software product; an FTS describes the behaviour of a software product by enabling and disabling parts of the system based on the which features are enabled.

There are numerous temporal logics that can be used to formally express requirements. Examples include LTL, CTL, CTL* and modal $\mu$-calculus \cite{LTL,PrinciplesOfModelChecking,Groote}. Of the different temporal logics, the modal $\mu$-calculus is the most expressive one; it subsumes the other temporal logics \cite{MuCalculusSubsumes}. 

In this thesis we aim to verify the software products of an SPL in a collective manner that exploits commonalities between the different products. Given an FTS $M$, describing the set of products $P$, and a modal $\mu$-calculus formula, we explore methods to find the largest set of products $P_s \subseteq P$ such that all products in $P_s$ satisfy the formula. Specifically, we aim to verify SPLs more efficiently than verifying the products independently.

\textit{Parity games} can be used to determine if an LTS behaves according to a modal $\mu$-calculus formula. Parity games are directed graphs that express a game played by two players \cite{Bradfield2018}. Every vertex in the graph is won by exactly one of the players and a parity game is globally \textit{solved} when it is determined for every vertex who the winner is. A parity game can be constructed from an LTS and a modal $\mu$-calculus formula such that solving the parity game provides the information needed to determine if the LTS behaves according to the formula \cite{Bradfield2018}.

We introduce a generalization of parity games, called \textit{variability parity games} (VPGs). A VPG expresses variability similar to how an FTS expresses variability. However, instead of using features a VPG expresses variability through \textit{configurations}. Parity games have a winner for every vertex, VPGs have a winner for every vertex configuration combination. A VPG is globally solved when it is determined for every vertex configuration combination who the winner is. We introduce a way of constructing a VPG from an FTS and a modal $\mu$-calculus formula such that solving the VPG provides the information needed to determine which products, described by the FTS, behave according to the formula.

We introduce several algorithms to solve VPGs. We also introduce algorithms to partially solve VPGs, in which case we only determine the winner of the vertex configuration combinations that are needed to determine which products, described by the FTS, behave according to the formula. This technique is called \textit{locally} solving a VPG. We can also locally solve a parity game, where we only determine the winner of the vertex that is needed to determine if the LTS behaves according to the formula. Besides introducing local variants of the novel VPG algorithms we also introduce local variants of two well known parity game algorithms, namely the recursive algorithm \cite{ZIELONKA1998135,MCNAUGHTON1993149} and the fixed-point iteration algorithm \cite{WALUKIEWICZ2002311,FPITE}.

Finally we implement the algorithms and compare their performances. We use two SPL models to create a number of VPGs. We compare the time it takes the algorithms to solve the VPGs with the time it takes to verify every product in the SPLs independently. For the independent verification approach we create parity games for all the products and requirements; these parity games are solved using existing parity game algorithms.

Through this experimental evaluation we show that we can indeed use a collective approach to more efficiently verify SPLs. The most efficient algorithm exploits commonalities between configuration by representing VPGs partially symbolic. This algorithm verifies the SPL properties 2 to 18 times quicker than an independent approach verifies them. Furthermore, we show that locally solving a VPG might improve the performance compared to globally solving a VPG; more so than locally solving a parity game improves the performance compared to globally solving a parity games.

\textit{Outline.} First, we explore work related to model-checking SPLs in Chapter \ref{chap_related}. Next, in Chapter \ref{chap_prelim}, we introduce the following preliminary concepts: LTSs, $\mu$-calculus, parity games, model-checking using parity games, two parity game algorithms and symbolically representing sets. In Chapter \ref{chap_problem} we formally introduce FTSs and the problem statement. We introduce VPGs in Chapter \ref{chap_VPGs} and show that they can be used to model-check FTSs. We introduce VPG solving algorithms in Chapter \ref{chap_solving} and in Chapter \ref{chap_local_solving} we present local variants. Finally, we discuss the implementation and experimental results in Chapter \ref{chap_experiments}.