Model verification techniques can be used to improve the quality of software. These techniques require the behaviour of the software to be modelled, these models can then be checked to verify that it behaves conforming to some formally specified requirement. These verification techniques are well studied, specifically techniques to verify a single software product.

\textit{Software product lines} (SPLs) are configurable software system that describe collections of similar software products. SPLs are systems that can be configured to result in different variants of the same system. So SPLs describe \textit{families} of software products where the products originate from the same system and often times have a lot of commonalities. The difference between the products in a family is called the \textit{variability} of the family. A family of products can be verified by using traditional verification techniques to verify every single product independently. However, verifying models is expensive in term of computing costs and the number of products in an SPL can grow large, therefore having to verify every single product independently is undesirable. In this thesis we explore techniques to verify a family of software products in a collective manner that exploits commonalities between the different products.

A common way of modelling the behaviour of software is by using \textit{labelled transition systems} (LTSs). While LTSs can model behaviour well they cannot model variability. Efforts to also model variability include I/O automata, modal transition systems and \textit{featured transition systems} (FTSs) (TODO: cite). Specifically the latter is well suited to model all the different behaviours of the software products as well as the variability of the entire system in a single model. FTSs use \textit{features} to express variability; a feature is an option that can be turned on or off for the system. In the context of FTSs, a set of features is synonymous with a software product; an FTS describes the behaviour of a software product by enabling and disabling parts of the system based on the which features are enabled.

There are numerous temporal logics that can be used to formally express requirements. Examples include LTL, CTL, CTL* and modal $\mu$-calculus. These languages can be extended to also be able to reason about features. Notable contributions are fLTL, fCTL and modal f$\mu$-calculus. These languages make it possible to express requirements that also reason about features. In this thesis we aim to effectively very requirements that do not reason about features. Of the different temporal logics, the modal $\mu$-calculus is the most expressive one; it subsumes the other temporal logics. We aim to determine which products, described by an FTS, behave according to a requirement expressed as a modal $\mu$-calculus formula.

\textit{Parity games} can be used to determine if an LTS behaves according to a modal $\mu$-calculus formula. Parity games are directed graphs that express a game played by two players. Every vertex in the graph is won by exactly one of the players and a parity game is \textit{solved} when it is determined for every vertex who the winner is. A parity game can be constructed from an LTS and a modal $\mu$-calculus formula such that solving the parity game provides the information needed to determine if the LTS behaves according to the formula.

We introduce a variation of parity games, called \textit{variability parity games} (VPGs). A VPG expresses variability similar to how an FTS expresses variability. However, instead of using features a VPG expresses variability through \textit{configurations}. Parity games have a winner for every vertex, VPGs have a winner for every vertex configuration combination. A VPG is solved when it is determined for every vertex configuration combination who the winner is. We introduce a way of constructing a VPG from an FTS and a modal $\mu$-calculus formula such that solving the VPG provides the information needed to determine which products, described by the FTS, behave according to the formula.

We introduce numerous algorithms to solve VPGs. We also introduce algorithms to partially solve VPGs, in this case we only determine the winner of the vertex configuration combinations that are needed to determine which products, described by the FTS, behave according to the formula. This technique is called \textit{locally} solving a VPG. We can also locally solve a parity game, where we only determine the winner of the vertex that is needed to determine if the LTS behaves according to the formula.

Finally we implement the algorithms and compare their performances. We use two SPLs to create a number of VPGs. We compare the time it takes the algorithms to solve the VPGs to the time it takes to verify every product in the SPLs independently. For the independent verification approach we create parity games for all the products and requirements; these parity games are solved using existing parity game algorithms.