Next we will consider Zielonka's recursive algorithm \cite{ZIELONKA1998135} which is a parity game solving algorithm that we can use to solve unified parity games. The algorithm reasons about sets of states for which certain properties hold which makes the algorithm particularly appropriate to use because we can represent sets of states in unified VPGs as functions that map to sets of configurations. As we will see later we can represent these sets of configurations symbolically to exploit similarity between them.
\subsubsection{Original Zielonka's recursive algorithm}
First we consider the original Zielonka's recursive algorithm, created from the constructive proof given in \cite{ZIELONKA1998135}, which solves solves total PGs. Pseudo code is presented in algorithm \ref{alg_zlnk_org}.

The algorithm has a worst running time complexity of $O(e*n^d)$ where $n$ is the number of vertices, $e$ the number of edges and $d$ the number of distinct priorities in the parity game. If we apply the algorithm to solve a VPG with configurations $\mathfrak{C}$ product based we get a running time of $O(|\mathfrak{C}| *e*n^d)$.
\begin{algorithm}
	\caption{$\textsc{RecursivePG}(\textit{PG } G = (V,V_0,V_1, E, \Omega))$}
	\label{alg_zlnk_org}
	\begin{algorithmic}[1]
		\State $m \gets \min\{ \Omega(v)\ |\ v \in V\}$
		\State $h \gets\max\{ \Omega(v)\ |\ v \in V\}$
		\If{$h = m$ or $V = \emptyset$}
		\If{$h$ is even or $V = \emptyset$}
		\State \Return $(V,\emptyset)$
		\Else
		\State \Return $(\emptyset, V)$
		\EndIf
		\EndIf
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{v \in V\ |\ \Omega(v) = h\}$
		\State $A \gets \alpha\textit{-Attr}(G, U)$
		\State $(W_0', W_1') \gets \textsc{RecursivePG}(G \backslash A)$
		\If{$W_{\overline{\alpha}}' =\emptyset$}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-Attr}(G,W_{\overline{\alpha}}')$
		\State $(W_0'', W_1'') \gets \textsc{RecursivePG}(G \backslash B)$
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}

An exhaustive explanation of the algorithm can be found in \cite{ZIELONKA1998135}, we do introduce the definitions used in the algorithm. First we introduce the notion of an attractor set. An attractor set is a set of vertices $A \subseteq V$ calculated for player $\alpha$ given set $U \subseteq V$ where player $\alpha$ has a strategy to go from any vertex in $A$ to a vertex in $U$.

\begin{definition}\cite{ZIELONKA1998135}
	\label{def_attr}Given parity game $G = (V,V_0,V_1,E,\Omega)$ and a non-empty set $U \subseteq V$ we define $\alpha\textit{-Attr}(G,U)$ such that
	\[U_0 = U \]
	For $i \geq 0$:
	\begin{align*}
	U_{i+1} = U_i\cup
	&\{v \in V_\alpha\ |\ \exists v' \in V : v' \in U_i \wedge (v,v') \in E \}\\
	\cup &\{v \in V_{\overline{\alpha}}\ |\ \forall v' \in V :(v,v') \in E \implies v' \in U_i \}
	\end{align*}
	\[\alpha\textit{-Attr}(G,U) = U_k \]
	such that for $k$ we have
	\[U_k = U_{k+1} \]
\end{definition}

Next we present the definition of a subgame, where a PG game is given and a set of vertices which are removed from the game resulting in a subgame.

\begin{definition}\cite{ZIELONKA1998135}
\label{def_org_subgame}
Given a parity game $G = (V,V_0,V_1, E,\Omega)$ and $U \subseteq V$ we define the subgame $G \backslash U$ to be the game $(V', V_0', V_1', E', \Omega)$ with:
\begin{itemize}
	\item $V' = V \backslash U$,
	\item $V_0' = V_0 \cap V'$,
	\item $V_1' = V_1 \cap V'$ and
	\item $E' = E \cap (V' \times V')$.
\end{itemize}
\end{definition}

We can relax the subgame definition given in \cite{ZIELONKA1998135} to a definition where we only remove vertices and not remove edges.

\begin{definition}
	\label{def_relaxed_subgame}
	Given a parity game $G = (V,V_0,V_1, E,\Omega)$ and $U \subseteq V$ we define the relaxed subgame $G \backslash U$ to be the game $(V', V_0', V_1', ', \Omega)$ with:
	\begin{itemize}
		\item $V' = V \backslash U$,
		\item $V_0' = V_0 \cap V'$ and
		\item $V_1' = V_1 \cap V'$.
	\end{itemize}
\end{definition}
We will show that using the relaxed subgame definition in the recursive algorithm gives the same result.
\begin{lemma}
	Using the relaxed subgame (\ref{def_relaxed_subgame}) definition in the recursive algorithm gives the same result as using the regular subgame definition (\ref{def_org_subgame}).
	\begin{proof}
		Let $E$ be the edge relation resulting from a regular subgame operation and $E'$ be the edge relation resulting from a relaxed subgame operation.
		
		We first observe that the difference between the two definitions is that in $E$ only edges exists that go from and go to vertices that are in $V$. In $E'$ edges can exists that go from and/or go to vertices that are not in $V$. We also find $E \subseteq E'$.
		
		Next we observe that the only place where edges are used in the algorithm is in the calculation of the attractor set. We will show that the attractor set calculated for $E$ is equal to the attractor set calculated for $E'$.
		
		Let $v \in V$, we distinguish two cases:
		\begin{itemize}
			\item Case: $v \in V_\alpha$.
			
			Vertex $v$ will only be attracted if there exists a $v' \in V$ such that there is an edge from $v$ to $v'$. Since $v$ and $v'$ are both in $V$ an edge $(v,v') \in E'$ will also exist in $E$, therefore the result is the same.
			\item Case: $v \in V_{\overline{\alpha}}$.
			
		    Vertex $v$ will only be attracted if all the edges that go to $v' \in V$ are in $U_i$. Since edges that go from $v$ to $v'' \notin V$ are not considered the result for both $E$ and $E'$ will be the same.
		\end{itemize}
	\end{proof}
\end{lemma}

\subsubsection{Recursive algorithm for unified VPGs}
We can modify the recursive algorithm to work with the function representation of vertices and edges introduced in section \ref{sec_unified_pg}. Pseudo code for the modified algorithm is presented in algorithm \ref{alg_zlnk_UVPG}.
\begin{algorithm}
	\caption{$\textsc{recursiveUVPG}(\textit{PG } G = (\\
		V : \hat{V} \rightarrow 2^\mathfrak{C},\\
		V_0 : \hat{V} \rightarrow 2^\mathfrak{C},\\
		V_1 : \hat{V} \rightarrow 2^\mathfrak{C},\\
		E : \hat{E} \rightarrow 2^\mathfrak{C},\\
		\Omega : \hat{V} \rightarrow \mathbb{N}))$}\label{alg_zlnk_UVPG}
	\begin{algorithmic}[1]
		\State $m \gets \min\{ \Omega(\hat{v})\ |\ V(\hat{v}) \neq \emptyset \}$
		\State $h \gets \max\{ \Omega(\hat{v})\ |\ V(\hat{v}) \neq \emptyset \}$
		\If{$h = m$ or $V(\hat{v}) = \lambda^\emptyset$}
		\If{$h$ is even or $V = \lambda^\emptyset$}
		\State \Return $(V,\lambda^\emptyset)$
		\Else
		\State \Return $(\lambda^\emptyset, V)$
		\EndIf
		\EndIf
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{ \hat{v} |\ V(\hat{v}) \neq \emptyset \wedge \Omega(\hat{v}) = h\}$
		\State $A \gets \alpha\textit{-FAttr}(G, U)$
		\State $(W_0', W_1') \gets \textsc{recursiveUVPG}(G \backslash A)$
		\If{$W_{\overline{\alpha}}' =\lambda^\emptyset$}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \lambda^\emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-FAttr}(G,W_{\overline{\alpha}}')$
		\State $(W_0'', W_1'') \gets \textsc{recursiveUVPG}(G \backslash B)$
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}
We have modified the attractor definition to work with the function-wise representation.
\begin{definition}
		\label{def_Uattr}Given unified VPG $G = (V, V_0,V_1,E,\Omega)$, represented function-wise, and a non-empty set $U \subseteq V$ we define $\alpha\textit{-FAttr}(G,U)$ such that
	\[U_0 = U \]
	For $i \geq 0$:
	\[
	U_{i+1}(\hat{v}) = U_i(\hat{v}) \cup \begin{cases}
\bigcup_{\hat{v}'} (V(\hat{v}) \cap E(\hat{v},\hat{v}') \cap U_i(\hat{v}')) & \text{if } V_{\alpha}(\hat{v}) \neq \emptyset \\
V(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E(\hat{v},\hat{v}')) \cup U_i(\hat{v}') \cup (\mathfrak{C}\backslash V(\hat{v}')) & \text{if } V_{\overline{\alpha}}(\hat{v}) \neq \emptyset \\
	\end{cases}
	\]
	\[\alpha\textit{-FAttr}(G,U) = U_k \]
	such that for $k$ we have
	\[U_k = U_{k+1} \]
\end{definition}
We will now prove that this new attractor definition gives a result equal to the original definition.
\begin{lemma}
	\label{lem_attr_equal}
	Given unified VPG $G = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ and set $\mathcal{U} \subseteq \mathcal{V}$ the function-wise attractor $\alpha\textit{-FAttr}(G,\mathcal{U})$ is equivalent to the set-wise attractor $\alpha\textit{-Attr}(G,\mathcal{U})$ for any $\alpha \in \{0,1\}$.
	\begin{proof}
		Let $V,V_0,V_1,E,U$ be the set-wise representation and $V^\lambda,V_0^\lambda,V_1^\lambda,E^\lambda,U^\lambda$ be the function-wise representation of $\mathcal{V},\mathcal{V}_0,\mathcal{V}_1,\mathcal{E},\mathcal{U}$ respectively.
		
		The following properties hold by definition:
		\[ (c,\hat{v}) \in X \iff c \in X^\lambda(\hat{v})\text{ for all } X\in \{V,V_0,V_1,U\}\]
		\[ ((c,\hat{v}),(c,\hat{v}')) \in E \iff c \in E^\lambda(\hat{v},\hat{v}') \]
		
		Since the attractors are inductively defined and $U_0$ and $U^\lambda_0$ are equivalent (because $U$ and $U^\lambda$ are equivalent) we have to prove that for some $i \geq 0$, with $U_i$ being equivalent to $U^\lambda_i$, the sets $U_{i+1}$ and $U^\lambda_{i+1}$ are equivalent. The sets $U_{i+1}$ and $U^\lambda_{i+1}$ are equivalent iff:
		\[ (c,\hat{v}) \in U_{i+1} \iff c \in U^\lambda_{i+1}(\hat{v}) \]
		Let $(c,\hat{v}) \in V$, we consider 4 cases.
		\begin{itemize}
			\item Case: $(c, \hat{v}) \in V_{\alpha}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. Consider $(c,\hat{v}) \notin U_i$, we have $c \notin U_i(\hat{v})$.
			
			
			It follows immediately that $c \in V^\lambda_{\alpha}(\hat{v})$ therefore $V^\lambda_{\alpha}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (V^\lambda(\hat{v}) \cap E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			There exists an $(c',\hat{v}') \in V$ such that $(c',\hat{v}') \in U_i$ and $((c,\hat{v}),(c',\hat{v}')) \in E$. Because edges don't cross configurations we can conclude that $c' = c$. Due to equivalence we have $c \in V^\lambda(\hat{v})$, $c \in U^\lambda_i(\hat{v}')$ and $c \in E^\lambda(\hat{v},\hat{v}')$. If we fill this in in the above formula we can conclude that $c \in U^\lambda_{i+1}(\hat{v})$.
			\item Case: $(c, \hat{v}) \in V_{\alpha}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			
			First we observe that $(c,\hat{v}) \notin U_i$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\alpha}(\hat{v})$ therefore $V^\lambda_{\alpha}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (V^\lambda(\hat{v}) \cap E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			Assume $c \in U^\lambda_{i+1}(\hat{v})$. There must exist a $\hat{v}'$ such that $c \in V^\lambda(\hat{v})$, $c \in E^\lambda(\hat{v},\hat{v}')$ and $c \in U^\lambda_i(\hat{v}')$. Due to equivalence we have a vertex $(c,\hat{v}) \in V$, $((c,\hat{v}),(c,\hat{v}')) \in E$ and $(c,\hat{v}') \in U_i$. In which case $(c,\hat{v})$ would be attracted and would be in $U_{i+1}$ which is a contradiction.
			\item Case: $(c, \hat{v}) \in V_{\overline{\alpha}}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. Consider $(c,\hat{v}) \notin U_i$, we have $c \notin U_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\overline{\alpha}}(\hat{v})$ therefore $V^\lambda_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \cup (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			
			Assume $c \notin U^\lambda_{i+1}(\hat{v})$. Because $c \in V^\lambda(\hat{v})$ there must exist an $\hat{v}$ such that
			\[ c \notin ((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \text{ and } c \notin U^\lambda_i(\hat{v}') \text{ and } c \notin (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			which is equal to
			\[ c \in E^\lambda(\hat{v},\hat{v}') \text{ and } c \notin U^\lambda_i(\hat{v}') \text{ and } c \in V^\lambda(\hat{v}') \]
			By equivalence we have $((c,\hat{v}),(c,\hat{v}')) \in E$, $(c,\hat{v}') \notin U_i$ and $(c,\hat{v}') \in V$. Which means that $(c,\hat{v})$ will not be attracted and $(c,\hat{v}) \notin U_{i+1}$ which is a contradiction.
			\item Case: $(c, \hat{v}) \in V_{\overline{\alpha}}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			First we observe that $(c,\hat{v}) \notin U_i$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\overline{\alpha}}(\hat{v})$ therefore $V^\lambda_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \cup (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			
			There must exist a $(c,\hat{v}') \in V$ such that 
			\[ ((c,\hat{v}),(c,\hat{v}')) \in E  \text{ and } (c,\hat{v}') \notin U_i \]
			By equivalence we have 
			\[ c \in V^\lambda(\hat{v}')  \text{ and } c \in E^\lambda(\hat{v},\hat{v}')  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			Which is equal to
			\[ c \notin (\mathfrak{C} \backslash V^\lambda(\hat{v}'))  \text{ and } c \notin (\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}'))  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			From which we conclude
			\[ c \notin ((\mathfrak{C} \backslash V^\lambda(\hat{v}')) \cup c \notin (\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup c \notin U^\lambda_i(\hat{v}')) \]
			Therefore we have $c \notin U^\lambda_{i+1}(\hat{v})$.
		\end{itemize}
	\end{proof}
\end{lemma}

We also modified the subgame definition to work with the function-wise representation. Note that this subgame definition is similar to the relaxed subgame definition (\ref{def_relaxed_subgame}) and not to the original subgame definition (\ref{def_org_subgame}).
\begin{definition}
	\label{def_Usubgame}
	For unified VPG $G = (V,V_0,V_1,E,\Omega)$, represented function-wise, and set $X \subseteq V$ we define the subgame $G \backslash X = (V',V_0',V_1',E,\Omega)$ such that:
	\begin{itemize}
		\item $V'(\hat{v}) = V(\hat{v}) \backslash X(\hat{v})$,
		\item $V_0'(\hat{v}) = V'(\hat{v}) \cap V_0(\hat{v})$ and
		\item $V_1'(\hat{v}) = V'(\hat{v}) \cap V_1(\hat{v})$.
	\end{itemize}
\end{definition}
We will now prove that this new subgame definition gives a result equal to the relaxed subgame definition.
\begin{lemma}
	\label{lem_subgame_eq}
	Given unified VPG $G = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ and set $\mathcal{U} \subseteq \mathcal{V}$ the function-wise subgame $G \backslash \mathcal{U}$ is equal to the relaxed set-wise subgame $G \backslash \mathcal{U}$.
	\begin{proof}
		Follows immediately from the subgame definitions (\ref{def_relaxed_subgame}, \ref{def_Usubgame}) and the equivalence relation between function-wise and set-wise games.
	\end{proof}
\end{lemma}

Next we prove the correctness of the algorithm by showing that the winning sets of the function-wise algorithm are equal to the winning sets of the set-wise algorithm.
\begin{theorem}
	Given unified VPG $\mathcal{G} = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ the winning sets resulting from \textsc{recursiveUVPG($\mathcal{G}$)} ran over the function-wise representation of $G$ is equal to the winning sets resulting from \textsc{RecursivePG($\mathcal{G}$)} ran over the set-wise representation of $G$.
	\begin{proof}
		Let $G = (V,V_0,V_1,E,\Omega)$ be the set-wise representation of $\mathcal{G}$ and $G^\lambda = (V^\lambda, V^\lambda_0, V^\lambda_1, E^\lambda, \Omega)$ be the function-wise representation of $\mathcal{G}$.
		
		Proof by induction on $\mathcal{G}$.
		
		\textbf{Base} $\mathcal{V} = \emptyset$. 
		
		\textsc{recursiveUVPG($G^\lambda$)} returns $\lambda^\emptyset$ and \textsc{RecursivePG($G$)} returns $\emptyset$, these two results are equal therefore the theorem holds in this case.
		
		\textbf{Base} $\min\{\Omega(v)\ |\ v \in \mathcal{V}\} = \max\{\Omega(v)\ |\ v \in \mathcal{V}\}$.
		
		\textsc{recursiveUVPG($G^\lambda$)} returns $\lambda^\emptyset$ and \textsc{RecursivePG($G$)} returns $\emptyset$, these two results are equal therefore the theorem holds in this case.
		
		\textbf{Step}
		
		Player $\alpha$ gets the same value in both algorithms since the highest priority is equal for both algorithms.
		
		Set $\{v \in V\ |\ \Omega(v) = h\}$ is equal to $\{ \hat{v} |\ V(\hat{v}) \neq \emptyset \wedge \Omega(\hat{v}) = h\}$ by equivalence definition. So the values for $U$ are equal in both algorithms.
		
		For the rest of the algorithm it is sufficient to see that attractor sets are equal if the game and input set are equal (as shown in lemma \ref{lem_attr_equal}) and that the created subgames are equal (as shown in lemma \ref{lem_subgame_eq}). Since the subgames are equal we can apply the theorem on it by induction and conclude that the winning sets are also equal.
	\end{proof}
\end{theorem}

We can now conclude that for VPG $\hat{G}$ vertex $\hat{v}$ is won by player $\alpha$ for configuration $c$ iff $c \in W_\alpha(\hat{v})$ with $(W_0,W_1) = \textsc{RecursiveUVPG}(G_{\downarrow})$.

\subsubsection{Function-wise attractor set}
Next we present an algorithm to calculate the function-wise attractor, the pseudo code is presented in algorithm \ref{alg_fattr_alg}. The algorithm considers vertices that are in the attracted set for some configuration, for every such vertex the algorithm tries to attract vertices that are connected by an incoming edge. If a vertex is attracted for some configuration then this vertex will also be considered. We prove the correctness of the algorithm in the following lemma and theorem.
\begin{algorithm}
	\caption{$\textsc{$\alpha$-FAttractor}(G, A : \hat{V} \rightarrow 2^\mathfrak{C})$}\label{alg_fattr_alg}
	\begin{algorithmic}[1]
		\State Queue $Q \gets \{\hat{v} \in \hat{V} \ |\ A(\hat{v}) \neq \emptyset  \}$
		\While{$Q$ is not empty}
		\State $\hat{v}' \gets Q.pop()$
		\For{$E(\hat{v},\hat{v}') \neq \emptyset$}
			\If{$A(\hat{v}) = V(\hat{v})$} \State \textbf{continue} \EndIf
			\If{$V_\alpha(\hat{v}) \neq \emptyset$}
				\State $a \gets V(\hat{v}) \cap E(\hat{v},\hat{v}') \cap A(\hat{v}')$
			\Else
				\State $a \gets V(\hat{v})$
				\For{$E(\hat{v},\hat{v}'') \neq \emptyset$}
					\State $a \gets a \cap (\mathfrak{C}\backslash E(\hat{v},\hat{v}'') \cup A(\hat{v}'') \cup \mathfrak{C} \backslash V(\hat{v}''))$
				\EndFor
			\EndIf
			\If{$a = \emptyset$} \State \textbf{continue} \EndIf
			\State $A(\hat{v}) \gets A(\hat{v}) \cup a$
			\State $Q.push(\hat{v})$
		\EndFor
		\EndWhile
		\State \Return $A$
	\end{algorithmic}
\end{algorithm}
\begin{lemma}
\label{lem_attr_requires_E}
Vertex $\hat{v}$ with configuration $c$, with $c \in V(\hat{v})$, can only be attracted if there is a vertex $\hat{v}'$ such that $c \in E(\hat{v}, \hat{v}')$ and $c \in U_i(\hat{v}')$.
\begin{proof}
	We first observe that a v If $V_\alpha(\hat{v}) \neq \emptyset$ then this property follows immediately from definition \ref{def_Uattr}. If $V_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ we note that parity games are total and therefore also total for every configuration (lemma \ref{lem_UVPG_total}), therefore vertex $\hat{v}$ has an outgoing edge to $\hat{w}$ such that $c \in E(\hat{v},\hat{w})$. For $\hat{v}$ with $c$ to be attracted we must have $c \in U_i(\hat{w)}$.
\end{proof}
\end{lemma}
\begin{theorem}
Set $A$ calculated by $\textsc{$\alpha$-FAttractor}(G,U)$ satisfies $A = \alpha\textit{-FAttr}(G,U)$.
	\begin{proof} We will prove two loop invariants over the while loop of the algorithm.
		
		\textbf{IV1}: For every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ with $c \in A(\hat{w})$ we have $c \in \alpha\textit{-FAttr}(G,U)(\hat{w})$.
		
		\textbf{IV2}: For every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ that can be attracted to $A$ either $c \in A(\hat{w})$ or there exists a $\hat{w}' \in Q$ such that $c \in E(\hat{w},\hat{w}')$.
		
		\textbf{Base}: Before the loop starts we have $A = U$, therefore IV1 holds. Furthermore all the vertices in $vert(A)$ are in $Q$ so IV2 also holds.
		
		\textbf{Step}: Consider the beginning of an iteration and assume IV1 and IV2 hold. To prove: IV1 and IV2 hold at the end of the iteration.
		
		Set $A$ only contains vertices with configurations that are in $\alpha\textit{-FAttr}(G,U)$. The set is only updated through lines 8-14 and 19 of the algorithm which reflects the exact definition of the attractor set therefore IV1 holds at the end of the iteration as well.
		
		Consider $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$, we distinguish three cases to prove IV2:
		\begin{itemize}
			\item $\hat{w}$ with $c$ can be attracted by the beginning of the iteration but not by the end.
			
			This case can't happen because $A(\hat{w})$ only increases during the algorithm for any $\hat{w}$ and the values for $E$ and $V$ are not changed throughout the algorithm.
			\item $\hat{w}$ with $c$ can't be attracted by the beginning of the iteration but can by the end.
			
			For $\hat{w}$ with $c$ to be able to be attracted at the end of the iteration there must be some $\hat{w}'$ with $c$ such that during the iteration $c$ was added to $A(\hat{w}')$ (lemma \ref{lem_attr_requires_E}). Every $\hat{w}'$ for which $A(\hat{w}')$ is updated is added to the queue (lines 16-20). Therefore there we have $\hat{w}' \in Q$ with $c \in E(\hat{w},\hat{w}')$ and IV1 holds.
			\item $\hat{w}$ with $c$ can be attracted by the beginning of the iteration and also by the end.
			
			Since IV2 holds at the beginning of the iteration we have either $c \in A(\hat{w})$ or we have some $\hat{w}' \in Q$ such that $c \in E(\hat{w},\hat{w}')$. In the former case IV2 holds trivially by the end of the iteration since $A(\hat{w})$ can only increase. For the latter case we distinguish two scenario's. 
			
			First we consider the case where vertex $\hat{v}'$ that is considered during the iteration (line 3 of the algorithm) is $\hat{w}'$. There is a vertex $c \in E(\hat{w},\hat{w}')$ by IV2. Therefore we can conclude that $\hat{w}$ is considered in the for loop starting at line $4$ and will be attracted in lines 8-14 and added to $A(\hat{w})$ in line 19. Therefore IV2 holds by the end of the iteration.
			
			Next we consider the case where $\hat{v}' \neq \hat{w}'$. In this case by the end of the iteration $\hat{w}'$ will still be in $Q$ and IV2 holds.
		\end{itemize}
	
		When the while loop ends IV1 and IV2 hold so for every for every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ that can be attracted to $A$ we have $c \in A(\hat{w})$. Since we start with $A = U$ can conclude the soundness of the algorithm. IV2 shows the completeness.
	\end{proof}
\end{theorem}


\subsubsection{Running time}
We will consider the running time for solving VPG $G = (V,V_0,V_1,E,\Omega,\mathfrak{C},\theta)$ product based, family based with a set-wise representation and family based with a function-wise representation. We will use $n$ to denote the number of vertices, $e$ the number of edges, $c$ the number of configurations and $d$ the number of distinct priorities.

As stated before the product based approach using the original algorithm gives a running time of $O(c * e * n^d)$. We can also apply the original algorithm to a unified VP (represented set-wise) for a family based approach, in this case we get a parity game with $c*n$ vertices and $O(c*e)$ edges. which gives a running time $O(c*e*(nc)^d)$.

Next we analyse the running time for the algorithm using function-wise representation. We first analyse the running time of the attractor set. A vertex will be added to the queue when this vertex is attracted for some configuration, this can only happen $c*n$, once for every vertex configuration combination. 

The first for loop considers all the incoming edges of a vertex. When we consider all vertices the for loop will have considered all edges, since we consider every vertex at most $c$ times the for loop will run at most $c*e$ times in total.

The second for loop considers all outgoing edges of a vertex. The vertices that are considered are the vertices that have an edge going to the vertex being considered by the while loop. Since the while loop considers $c*n$ vertices the second for loop runs in total at most $c * n * e$ times. The loop itself performs set operations on the set of configurations which can be done in $O(c)$. This gives a total running time for the attractor set of $O(n*c^2*e)$.

We will now analyse the recursion of the function-wise algorithm, first we define $m = cn$ for convenience. The first subgame created in the algorithm decreases $d$ by one, the second subgame decreases the $m$ by one. This gives the following recursion:
\begin{align*}
T(m,d) &\leq T(m, d-1) + T(m-1, d) + O(n*c^2*e)\\
T(m,1) &= O(m)\\
T(0,d) &= O(m)
\end{align*}
From which we get 
\begin{align*}
T(m,d) &\leq T(m, d-1) + T(m-1, d) + O(n*c^2*e)\\
&\leq m*T(m, d-1) + m*O(n*c^2*e) + O(m)\\
&\leq m*T(m, d-1) + (m+1)O(n*c^2*e)\\
T(m,1) &= O(m)
\end{align*}
We will now prove that $T(m,d) \leq (m+d)^dO(n*c^2*e)$ by induction on $d$.

\textbf{Base} $d = 1$: $T(m,1) = O(m) \leq O(n*c^2*e)$.

\textbf{step} 
\begin{align*}
T(m,d) &\leq m*T(m,d-1) + (m+1)O(c^2 + n^3)\\
&\leq m*(m+d-1)^{d-1}O(n*c^2*e) + (m+1)O(n*c^2*e)
\end{align*}
Since $d > 1$ we have $m \leq m+d-1$
\begin{align*}
T(m,d) &\leq (m+d-1)^{d}O(n*c^2*e) + (m+1)O(n*c^2*e)\\
& = ((m+d-1)^d + m + 1)O(n*c^2*e)
\end{align*}
We have $(m+d-1)^d + m + 1 \leq (m+d)^d$ (using lemma \ref{lem_md_ineq}), we find:\\
\[ T(m,d) \leq (m+d)^dO(n*c^2*e) \]

We conclude that the running time for the function-wise algorithm is $O((cn+d)^dn*c^2*e) = O(n*c^2*e(cn)^d)$.