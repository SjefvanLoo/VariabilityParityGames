We can use the original Zielonka's recursive algorithm to solve VPGs by creating one big parity game of a VPG through a process we introduce called \textit{unification}. This parity game can be solved using the original recursive algorithm. However, we introduce a way of representing this parity game that potentially increases performance and exploits commonalities between different configurations in the VPG.

\subsection{Unified parity games}
We can create a parity game from a VPG by taking all the projections of the VPG, which are parity games, and combining them into one parity games by taking the union of them. We call the resulting parity games the \textit{unification} of the VPG. A parity game that is the result of a unification is called a \textit{unified parity game}. Also any subgame of it will be called a unified parity games. A unified parity game always has a VPG from which it originated.
\begin{definition}
	Given VPG $\hat{G} = (\hat{V},\hat{V}_0,\hat{V}_1, \hat{E},\hat{\Omega}, \mathfrak{C},\theta)$ we define the unification of $\hat{G}$, denoted by $\hat{G}_{\downarrow}$, as
	\[  \hat{G}_{\downarrow} = \biguplus_{c\in \mathfrak{C}}\hat{G}_{|c} \]
	where the disjoint union of two parity games is defined as
	\[ (V,V_0,V_1,E,\Omega) \uplus (V',V_0',V_1',E',\Omega') = (V \uplus V', V_0 \uplus V_0', V_1 \uplus V_1', E \uplus E', \Omega \uplus \Omega') \]
	and the disjoint union of functions $\Omega : V \rightarrow \mathbb{N}$ and $\Omega' : V' \rightarrow \mathbb{N}$ is defined as
	\[ (\Omega \uplus \Omega')(v) = \begin{cases}
	\Omega(v) & \text{if }v \in V \\
	\Omega'(v) & \text{if }v \in V'
	\end{cases}\]
\end{definition}
In this section we use the hat decoration ($\hat{G},\hat{V},\hat{E},\hat{\Omega},\hat{W}$) when referring to a VPG and use no hat decoration when referring to a (unified) parity game.

Every vertex in unified parity game $\hat{G}_{\downarrow}$ originates from a configuration and an original vertex. Therefore we can consider every vertex in a unification as a vertex-configuration pair, i.e. $V = \mathfrak{C} \times \hat{V}$. We can consider edges in a unification similarly, so $E \subseteq (\mathfrak{C} \times \hat{V}) \times (\mathfrak{C} \times \hat{V})$. Note that edges do not cross configurations, so for every $((c,\hat{v}) , (c',\hat{v}')) \in E$ we have $c = c'$. We call set $\hat{V}$ the \textit{origin vertices} of a unified parity game.
\begin{example}
Figure \ref{fig:VPG2UPG} shows a VPG and its the unification.
	\begin{figure}[h]
		\centering
		\begin{subfigure}{1\textwidth}
			\centering
			\begin{tikzpicture}[->]
				\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
				\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
				
				\node[odd, label=west:$\hat{v}_1$] (v1) at (10,10) {2};
				\node[even,label=west:$\hat{v}_2$] (v2) at (10,8) {1};
				\node[odd,label=south:$\hat{v}_3$] (v3) at (12,8) {0};
				
				\path (v1) edge[loop above] node[above]{$\{c_1\}$} (v1);
				\path (v1) edge[bend right] node[left]{$\{c_1,c_2\}$} (v2);
				\path (v2) edge[bend right] node[right]{$\{c_1,c_2\}$} (v1);
				\path (v2) edge node[above]{$\{c_1,c_2\}$} (v3);
				\path (v3) edge[bend left] node[below]{$\{c_2\}$} (v2);
				\path (v3) edge[bend right=40] node[right]{$\{c_1\}$} (v1);
				\path (v3) edge[loop right] node[right]{$\{c_1\}$} (v3);
			\end{tikzpicture}
			\caption{VPG with 2 configurations}
		\end{subfigure}\\
		\begin{subfigure}{1\textwidth}
			\centering
			\begin{tikzpicture}[->]
				\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
				\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
				
				\node[odd, label={west:$(c_1,\hat{v}_1)$}] (v1) at (10,10) {2};
				\node[even,label={west:$(c_1,\hat{v}_2)$}] (v2) at (10,8) {1};
				\node[odd,label={south:$(c_1,\hat{v}_3)$}] (v3) at (12,8) {0};
				
				\path (v1) edge[loop above] (v1);
				\path (v1) edge[bend right] (v2);
				\path (v2) edge[bend right] (v1);
				\path (v2) edge (v3);
				\path (v3) edge[bend right=40] (v1);
				\path (v3) edge[loop right] (v3);
			\end{tikzpicture}
				\begin{tikzpicture}[->]
				\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
				\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
				
				\node[odd, label={east:$(c_2,\hat{v}_1)$}] (v1) at (10,10) {2};
				\node[even,label={south:$(c_2,\hat{v}_2)$}] (v2) at (10,8) {1};
				\node[odd,label={south:$(c_2,\hat{v}_3)$}] (v3) at (12,8) {0};
				
				\path (v1) edge[bend right] (v2);
				\path (v2) edge[bend right] (v1);
				\path (v2) edge (v3);
				\path (v3) edge[bend left] (v2);
			\end{tikzpicture}
			\caption{Unified parity game, created by unifying the two projections}
		\end{subfigure}
		\caption{A VPG with its corresponding unified parity game}
		\label{fig:VPG2UPG}
	\end{figure}
\end{example}

Clearly solving unified parity game $\hat{G}_{\downarrow}$ solves all the projections of VPG $\hat{G} = (\hat{V},\hat{V}_0,\hat{V}_1,\hat{E},\hat{E},\mathfrak{C},\theta)$. Theorem \ref{the_winning_set_is_equal_to_proj_winning_set} shows that if we solve all the projections of a VPG we have solved the VPG. So solving $\hat{G}_{\downarrow}$ also solves $\hat{G}$. Consider winning sets $(W^c_0, W^c_1)$ for $\hat{G}$ played for configuration $c$ and winning sets $(Q_0,Q_1)$ for $\hat{G}_{\downarrow}$. Using Theorem \ref{the_winning_set_is_equal_to_proj_winning_set} we find the following relation:
\[ W^c_\alpha = \{\hat{v}\ |\ (c,\hat{v}) \in Q_\alpha\} \]
\subsubsection{Projections and totality}
A unified parity game can be projected onto a configuration to get one of the parity games from which it is the union. This is very similar to the projection of a VPG onto a configuration. Specifically we have for VPG $\hat{G}$ and configuration $c$ that $\hat{G}_{|c} = (\hat{G}_{\downarrow})_{|c}$. Eventhough these definitions are so similar we do need to introduce the projection of unified parity games to be able to reason about projections of subgames of unified parity games.
\begin{definition}
	The projection of unified parity game $G = (V,V_0, V_1,E,{\Omega})$ to configuration $c$, denoted as $G_{|c}$, is the parity game $(V',V_0',V_1',E',\Omega)$ such that:
	\begin{itemize}
		\item $V' = \{\hat{v}\ |\ (c,\hat{v}) \in V \}$,
		\item $V_0' = \{\hat{v}\ |\ (c,\hat{v}) \in V_0 \}$,
		\item $V_1' = \{\hat{v}\ |\ (c,\hat{v}) \in V_1 \}$ and
		\item $E' = \{ (\hat{v},\hat{w})\ |\ ((c,\hat{v}),(c,\hat{w})) \in E \} $
	\end{itemize}
\end{definition}

One of the properties of a parity game is its totality; a game is total if every vertex has at least one outgoing vertex. The VPGs we consider are also total, meaning that every vertex has, for every configuration $c \in \mathfrak{C}$, at least one outgoing edge admitting $c$. Because VPGs are total their unifications are also total. Since edges in a unified parity game do not cross configurations the projection of a total unified parity game is also total.

\subsection{Solving unified parity games}
Since unified parity games are total they can be solved using Zielonka's recursive algorithm. The recursive algorithm revolves around the attractor operation. Consider the example presented in Figure \ref{fig:VPG2UPG}. Vertices with the highest priority are 
\[ \{(c_1,\hat{v}_1),(c_2,\hat{v}_1)\}\]
attracting these for player $0$ gives the set 
\begin{align*}
\{(c_1,\hat{v}_1),&(c_2,\hat{v}_1),\\
(c_1,\hat{v}_2),&(c_2,\hat{v}_2),\\
 &(c_2,\hat{v}_3)\}
\end{align*}
The algorithm tries to attract vertices $(c_1,\hat{v}_2)$ and $(c_2,\hat{v}_2)$ because they have edges to $\{(c_1,\hat{v}_1), (c_2,\hat{v}_1)\}$. So the algorithm, in this case, asks the questions: "Can vertices $(c_1,\hat{v}_2)$ and $(c_2,\hat{v}_2)$ be attracted?" We could also ask the question: "For which configurations can we attract origin vertex $\hat{v}_2$?" Since the vertices in unified parity games are pairs of configurations and origin vertices we can, instead of considering vertices individually, consider origin vertices and try to attract as many configurations as possible for each origin vertex. This is the idea of the collective recursive algorithm for VPGs we present next. We introduce a way of efficiently representing unified parity games and an algorithm that behaves the same as the original recursive algorithm but uses the modified representation. Using this representation we can create an attractor set algorithm that tries to attract as many configurations per origin vertex as possible instead of trying to attract each vertex individually.

In VPGs originating from FTSs a large number of edges admit all configurations (as is evident from Definition \ref{def_FTS2VPG}). Furthermore the sets that do not admit all configurations originate from the boolean formulas guarding transitions in the FTS. As argued before, these sets will most likely admit many configurations, because in many cases the boolean function will simply include or exclude a small number of features. Because of these two facts we hypothesise that VPGs originating from FTSs have edge guard sets that are relatively large (i.e. admit many of the configurations) and therefore we can attract many configurations at the same time per origin vertex.

\subsection{Representing unified parity games}
Unified parity games have a specific structure because they are the union of parity games that have the same vertices with the same owner and priority. Because they have the same priority we do not actually need to create a new function that is the unification of all the projections, we can simply use the original priority assignment function because the following relation holds:
\[ \Omega(c,\hat{v}) = \hat{\Omega}(\hat{v}) \]
Similarly we can use the original partition sets $\hat{V}_0$ and $\hat{V}_1$ instead of having the new partition $V_0$ and $V_1$ because the following relations hold:
\[ (c,\hat{v}) \in V_0 \iff \hat{v}\in \hat{V}_0 \]
\[ (c,\hat{v}) \in V_1 \iff \hat{v}\in \hat{V}_1 \]
So instead of considering unified parity game $(V,V_0,V_1,E,\Omega)$ we consider $(V,\hat{V}_0,\hat{V}_1,E,\hat{\Omega})$. 

Next we consider how we represent vertices and edges in a unified parity game. A set $X \subseteq (\mathfrak{C} \times \hat{V})$ can be represented as a total function $X^\lambda : \hat{V} \rightarrow 2^\mathfrak{C}$. The set $X$ and function $X^\lambda$ are equivalent, denoted by the operator $=_\lambda: 2^{\mathfrak{C} \times \hat{V}} \times (\hat{V} \rightarrow 2^\mathfrak{C}) \rightarrow \mathbb{B}$, such that
\[ X =_\lambda X^\lambda \text{ if and only if } (c,\hat{v}) \in X \iff c \in X^\lambda(\hat{v})\text{ for all }c \in \mathfrak{C}\text{ and }\hat{v} \in \hat{V} \]
We can also represent edges as a total function $E^\lambda : \hat{E} \rightarrow 2^\mathfrak{C}$. The set $E$ and function $E^\lambda$ are equivalent, denoted by the operator $=_\lambda 2^{(\mathfrak{C} \times \hat{V}) \times(\mathfrak{C} \times \hat{V})} \times (\hat{E} \rightarrow 2^\mathfrak{C}) \rightarrow \mathbb{B}$, such that:
\[ E =_\lambda E^\lambda \text{ if and only if } ((c,\hat{v}),(c,\hat{v}')) \in E \iff c \in f(\hat{v},\hat{v}')\text{ for all }c \in \mathfrak{C}\text{ and }\hat{v},\hat{v}' \in \hat{V} \]
We use the $=_\lambda$ operator to indicate that a set and a function represent the same vertices or edges. For convenience of notation we denote equality for edges and vertices both using the $=_\lambda$ operator. We define $\lambda^\emptyset$ to be the function that maps every element to $\emptyset$, clearly $\lambda^\emptyset =_\lambda \emptyset$. 

We call using a set of pairs to represent vertices and edges a \textit{set-wise} representation and using functions a \textit{function-wise} representation.
\begin{example}
	We consider a few examples of (sub)games and show their set-wise and function-wise representation. First reconsider the following unified parity game.
	\begin{center}
		\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node[odd, label={west:$(c_1,\hat{v}_1)$}] (c1v1) at (9.5,10) {2};
			\node[even,label={west:$(c_1,\hat{v}_2)$}] (c1v2) at (9.5,8) {1};
			\node[even,label={south:$(c_1,\hat{v}_3)$}] (c1v3) at (11.5,8) {0};
			
			\node[odd, label={east:$(c_2,\hat{v}_1)$}] (c2v1) at (13.5,10) {2};
			\node[even,label={south:$(c_2,\hat{v}_2)$}] (c2v2) at (13.5,8) {1};
			\node[even,label={east:$(c_2,\hat{v}_3)$}] (c2v3) at (15.5,8) {0};
			
			\path (c1v1) edge[loop above] (c1v1);
			\path (c1v1) edge[bend right] (c1v2);
			\path (c1v2) edge[bend right] (c1v1);
			\path (c1v2) edge (c1v3);
			\path (c1v3) edge[bend right=40] (c1v1);
			\path (c1v3) edge[loop right] (c1v3);
			
			\path (c2v1) edge[bend right] (c2v2);
			\path (c2v2) edge[bend right] (c2v1);
			\path (c2v2) edge (c2v3);
			\path (c2v3) edge[bend left] (c2v2);
		\end{tikzpicture}
	\end{center}
	This game can be represented set-wise:
	\begin{align*}
	V = \{&(c_1,\hat{v}_1),(c_2,\hat{v}_1),(c_1,\hat{v}_2),(c_2,\hat{v}_2),(c_1,\hat{v}_3),(c_2,\hat{v}_3) \}\\
	E = \{& ((c_1,\hat{v}_1),(c_1,\hat{v}_1)),((c_1,\hat{v}_1),(c_1,\hat{v}_2)),((c_1,\hat{v}_2),(c_1,\hat{v}_1)),\\
	&((c_1,\hat{v}_2),(c_1,\hat{v}_3)),((c_1,\hat{v}_3),(c_1,\hat{v}_1)),((c_1,\hat{v}_3),(c_1,\hat{v}_3)), \\
	&((c_2,\hat{v}_1),(c_2,\hat{v}_2)),((c_2,\hat{v}_2),(c_2,\hat{v}_1)),((c_2,\hat{v}_2),(c_2,\hat{v}_3)),((c_2,\hat{v}_3),(c_2,\hat{v}_2))\}
	\end{align*}
	and function-wise:
	\begin{align*}
	V^\lambda = \{&\hat{v}_1 \mapsto \{c_1,c_2\},\hat{v}_2 \mapsto \{c_1,c_2\},\hat{v}_3 \mapsto \{c_1,c_2\}\}\\
	E^\lambda = \{&(\hat{v}_1,\hat{v}_2) \mapsto \{c_1,c_2\},(\hat{v}_2,\hat{v}_1) \mapsto \{c_1,c_2\},(\hat{v}_2,\hat{v}_3) \mapsto \{c_1,c_2\},\\
	&(\hat{v}_1,\hat{v}_1) \mapsto \{c_1\},\\
	&(\hat{v}_3,\hat{v}_1) \mapsto \{c_1\},\\
	&(\hat{v}_3,\hat{v}_2) \mapsto \{c_2\},\\
	&(\hat{v}_3,\hat{v}_3) \mapsto \{c_1\}\}
	\end{align*}
	Consider the following subgame:
	\begin{center}
		\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node[odd, label={west:$(c_1,\hat{v}_1)$}] (c1v1) at (10,10) {2};
			
			\node[odd, label={east:$(c_2,\hat{v}_1)$}] (c2v1) at (13.5,10) {2};
			\node[even,label={south:$(c_2,\hat{v}_2)$}] (c2v2) at (13.5,8) {1};
			
			\path (c1v1) edge[loop above] (c1v1);
			
			\path (c2v1) edge[bend right] (c2v2);
			\path (c2v2) edge[bend right] (c2v1);
		\end{tikzpicture}
	\end{center}
	This subgame can be represented set-wise:
	\begin{align*}
	V = \{&(c_1,\hat{v}_1),(c_2,\hat{v}_1),(c_2,\hat{v}_2) \}\\
	E = \{& ((c_1,\hat{v}_1),(c_1,\hat{v}_1)), \\
	&((c_2,\hat{v}_1),(c_2,\hat{v}_2)),((c_2,\hat{v}_2),(c_2,\hat{v}_1)) \}
	\end{align*}
	and function-wise:
	\begin{align*}
	V^\lambda = \{&\hat{v}_1 \mapsto \{c_1,c_2\},\hat{v}_2 \mapsto \{c_2\},\hat{v}_3 \mapsto \emptyset\}\\
	E^\lambda = \{&(\hat{v}_1,\hat{v}_2) \mapsto \{c_2\},(\hat{v}_2,\hat{v}_1) \mapsto \{c_2\},(\hat{v}_2,\hat{v}_3) \mapsto \emptyset,\\
	&(\hat{v}_1,\hat{v}_1) \mapsto \{c_1\},\\
	&(\hat{v}_3,\hat{v}_1) \mapsto \emptyset,\\
	&(\hat{v}_3,\hat{v}_2) \mapsto \emptyset\}
	\end{align*}
	Finally consider an empty subgame which we can represent set-wise:
	\[ V = \emptyset, E = \emptyset \]
	and function-wise:
	\[ V^\lambda = \lambda^\emptyset, E^\lambda = \lambda^\emptyset \]
\end{example}

We define the union of two functions $X^\lambda : \hat{V} \rightarrow 2^\mathfrak{C}$ and $Y^\lambda : \hat{V} \rightarrow 2^\mathfrak{C}$ as
\[ (X^\lambda \cup Y^\lambda)(\hat{v}) = X^\lambda(\hat{v}) \cup Y^\lambda(\hat{v})\]
Given $X^\lambda =_\lambda X$ and $Y^\lambda =_\lambda Y$, then clearly $X^\lambda \cup Y^\lambda =_\lambda X \cup Y$. We also define the subset or equal operator for two functions $X^\lambda : \hat{V} \rightarrow 2^\mathfrak{C}$ and $Y^\lambda : \hat{V} \rightarrow 2^\mathfrak{C}$ as
\[ X^\lambda \subseteq Y^\lambda\text{ if and only if } X^\lambda(\hat{v}) \subseteq Y^\lambda(\hat{v})\text{ for all }\hat{v} \in \hat{V} \]
Given $X^\lambda =_\lambda X$ and $Y^\lambda =_\lambda Y$, then clearly $X^\lambda \subseteq Y^\lambda$ if and only if $X \subseteq Y$.

\subsection{Algorithms}
Using the recursive algorithm as a basis we can solve a VPG in numerous ways. First of all we can solve the projections, i.e. solve the VPG independently. Alternatively we can solve it collectively using a set-wise representation or a function-wise representation. For the function-wise representation we are working with functions mapping vertices and edges to sets of configurations. These sets of configurations can either be represented explicitly or symbolically. The following diagram shows the different algorithms:
\begin{center}
	\begin{forest}
		[Recursive algorithm, for tree={parent anchor=south, child anchor=north, align=center, s sep=5mm}
		[Independent]
		[Collective
		[Set-wise]
		[Function-wise
		[Explicit]
		[Symbolic]
		]
		]
		]
	\end{forest}
\end{center}
The independent approach uses the original algorithm repeatedly; once for every projection. The collective set-wise approach also uses the original algorithm, applied to a unified parity game. The function-wise representation requires modifications to the algorithm, as we try to attract multiple configurations at the same time. As we will discuss later, this modified algorithm relies heavily on set operations over sets of configurations. 

\subsubsection{Symbolically representing sets of configurations}
\label{sec:symrepconfs}
For VPGs originating from an FTS, the configuration sets guarding the edges either admit all configurations or originate from boolean functions over the features. These boolean functions will most likely be relatively simple and are therefore specifically appropriate to represent as BDDs.

Set operations $\cap,\cup,\backslash$ over two explicit sets can be performed in $O(m)$ where $m$ is the maximum size of the sets. This is better than the time complexity of a set operation using BDDs, which is $O(m^2)$ (as explained in preliminary section \ref{sec_prelim_bdd}). However if the BDDs are small then the set size can still be large but the set operations are performed very quickly. This is a trade-off between worst-case time complexity and actual running time; using a symbolic representation might yield better results if the sets are structured in such a way that the BDDs are small, however if the sets are not structures in a way that the BDDs are small then the running time is worse than with an explicit representation.

We hypothesize that since the collective function-wise symbolic recursive algorithm relies heavily on set operations over sets of configurations this algorithm will perform well when solving VPGs originating from FTSs.

\subsubsection{A note on symbolically solving games}
The function-wise algorithm has two variants: an explicit and a symbolic variant. In the explicit variant both the game graph and the sets of configurations are represented explicitly. In the symbolic variant the sets of configurations are represented symbolically, however the graph is still represented explicitly, so the algorithm is partially symbolic and partially explicit. Alternatively an algorithm could completely work symbolically by representing both the graph and the sets of configurations symbolically.

Solving parity games symbolically has been studied in \cite{BDDSolvingPG}. The obstacle is that representing graphs with a large number of nodes can make the corresponding BDDs very complex if no underlying structure is known for the graph. In such a case performance decreases rapidly. For model verification problems a game graph can conceivably be represented as a BDD by using the structure of the original model to build the BDD. However this is not trivial as argued in \cite{BDDSolvingPG}. As to not repeat work done in \cite{BDDSolvingPG} we only consider algorithms where we represent the graph explicitly. 

\subsection{Recursive algorithm using a function-wise representation}
The recursive algorithm can be modified to work with the function-wise representation of vertices and edges. The algorithm behaves the same as the original; operations are modified to work with the different representation.  Pseudo code for the modified algorithm is presented in Algorithm \ref{alg_zlnk_UVPG}. Note that for this pseudo code no distinction is needed between explicit and symbolic representations of sets of configurations.
\begin{algorithm}
	\caption{$\textsc{RecursiveUPG}(\textit{unified parity game } G = (\\
		V^\lambda : \hat{V} \rightarrow 2^\mathfrak{C},\\
		\hat{V}_0 \subseteq \hat{V},\\
		\hat{V}_1 \subseteq \hat{V},\\
		E^\lambda : \hat{E} \rightarrow 2^\mathfrak{C},\\
		\hat{\Omega} : \hat{V}\rightarrow \mathbb{N}))$}\label{alg_zlnk_UVPG}
	\begin{algorithmic}[1]
		\If{$V^\lambda = \lambda^\emptyset$}
		\State \Return $(\lambda^\emptyset, (\lambda^\emptyset)$
		\EndIf
		\State $h \gets \max\{ \hat{\Omega}(\hat{v})\ |\ V^\lambda(\hat{v}) \neq \emptyset \}$
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U^\lambda \gets \lambda^\emptyset$, $U^\lambda(\hat{v}) \gets V^\lambda(\hat{v})$ for all $\hat{v}$ with $\hat{\Omega}(\hat{v}) = h$
		\State $A^\lambda \gets \alpha\textit{-FAttr}(G, U^\lambda)$
		\State $({W^\lambda_0}', {W^\lambda_1}') \gets \textsc{RecursiveUPG}(G \backslash A^\lambda)$
		\If{${W^\lambda_{\overline{\alpha}}}' =\lambda^\emptyset$}
		\State $W^\lambda_\alpha \gets A^\lambda \cup {W^\lambda_\alpha}'$
		\State $W^\lambda_{\overline{\alpha}} \gets \lambda^\emptyset$
		\Else
		\State $B^\lambda \gets \overline{\alpha}\textit{-FAttr}(G,{W^\lambda_{\overline{\alpha}}}')$
		\State $({W^\lambda_0}'', {W^\lambda_1}'') \gets \textsc{RecursiveUPG}(G \backslash B^\lambda)$
		\State $W^\lambda_\alpha \gets {W^\lambda_\alpha}''$
		\State $W^\lambda_{\overline{\alpha}} \gets {W^\lambda_{\overline{\alpha}}}'' \cup B^\lambda$
		\EndIf
		\State \Return $(W^\lambda_0, W^\lambda_1)$
	\end{algorithmic}
\end{algorithm}

We introduce a modified attractor definition to work with the function-wise representation.
\begin{definition}
		\label{def_Uattr}Given unified parity game $G = (V^\lambda, \hat{V}_0,\hat{V}_1,E^\lambda,\hat{\Omega})$ and a non-empty set $U^\lambda \subseteq V^\lambda$, both represented function-wise, we define $\alpha\textit{-FAttr}(G^\lambda,U^\lambda)$ such that
	\[U^\lambda_0(\hat{v}) = U^\lambda(\hat{v}) \]
	For $i \geq 0$:
	\[
	U^\lambda_{i+1}(\hat{v}) = U^\lambda_i(\hat{v}) \cup \begin{cases}
V^\lambda(\hat{v}) \cap \bigcup_{\hat{v}'} (E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) & \text{if } \hat{v} \in \hat{V_{\alpha}}\\
V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}')) & \text{if }\hat{v} \in  \hat{V_{\overline{\alpha}}} \\
	\end{cases}
	\]
	Finally:
	\[\alpha\textit{-FAttr}(G^\lambda,U^\lambda)(\hat{v}) = \bigcup_{i \geq 0} U^\lambda_i(\hat{v}) \]
\end{definition}
This attractor definition relies heavily on performing set operations on sets of configurations. We will show later that this definition is equal to the original attractor set definition (Definition \ref{def_attr}). 

We also introduce a modified subgame definition to work with the function-wise representation.
\begin{definition}
	\label{def_Usubgame}
	For unified parity game $G = (V^\lambda,\hat{V}_0,\hat{V}_1,E^\lambda,\hat{\Omega})$ and set $X^\lambda \subseteq V^\lambda$, both represented function-wise, we define the subgame $G \backslash X^\lambda = ({V^\lambda}',\hat{V}_0,\hat{V}_1,{E^\lambda}',\hat{\Omega})$ such that:
	\begin{itemize}
		\item ${V^\lambda}'(\hat{v}) = V^\lambda(\hat{v}) \backslash X^\lambda(\hat{v})$
		\item ${E^\lambda}'(\hat{v},\hat{v}') = E^\lambda(\hat{v},\hat{v}') \cap {V^\lambda}'(\hat{v}) \cap {V^\lambda}'(\hat{v}')$
	\end{itemize}
\end{definition}
Note that we can omit the modification to the partition ($V_0$ and $V_1$) because, as we have seen, we can use the partitioning from the VPG in the representation of unified parity games. As we will show later, this definition is equal to the original subgame definition (Definition \ref{def_org_subgame}).

\begin{example}
	Consider unified parity game $G = (V^\lambda,\hat{V}_0,\hat{V}_1,E^\lambda,\hat{\Omega})$, originating from a VPG with configurations $\mathfrak{C} = \{c_1,c_2,c_3\}$, represented function-wise in Figure \ref{fig:upg}. We depict every $(v,w)$ for which $E^\lambda(v,w) \neq \emptyset$ with an edge annotated by the set $E^\lambda(v,w)$. All the origin vertices are depicted and for every origin vertex $\hat{v}$ we annotate the square or diamond with a label $\hat{v}\ |\ C$ where $C = V^\lambda(\hat{v})$.
	\begin{figure}[h]
		\centering
		\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node[odd, label=north:$\hat{v}_1\ |\ \mathfrak{C}$] (v1) at (20,20) {5};
			\node[even,label=north:$\hat{v}_2\ |\ \mathfrak{C}$] (v2) at (23,20) {6};
			\node[even,label=north:$\hat{v}_3\ |\ \mathfrak{C}$] (v3) at (26,20) {4};
			
			\node[even,label=west:$\hat{v}_4\ |\ \mathfrak{C}$]  (v4) at (20,17) {1};
			\node[odd, label=north east:$\hat{v}_5\ |\ \mathfrak{C}$] (v5) at (23,17) {2};
			\node[odd, label=east:$\hat{v}_6\ |\ \mathfrak{C}$] (v6) at (26,17) {3};
			
			\node[odd, label=south:$\hat{v}_7\ |\ \mathfrak{C}$] (v7) at (23,14) {2};
			
			
			\path (v1) edge node[above]{$\mathfrak{C}$} (v2);
			\path (v3) edge node[above]{$\mathfrak{C}$} (v2);
			
			\path (v4) edge node[left]{$\{c_1,c_2\}$} (v1);
			\path (v2) edge node[fill=white]{$\{c_1,c_2\}$} (v4);
			\path (v4) edge node[above]{$\{c_1,c_3\}$} (v5);
			\path (v5) edge node[left]{$\mathfrak{C}$} (v2);
			\path (v6) edge node[fill=white]{$\{c_1,c_2\}$} (v5);
			\path (v2) edge node[fill=white]{$\{c_1,c_3\}$} (v6);
			\path (v6) edge node[right]{$\{c_1,c_3\}$} (v3);
			
			
			\path (v7) edge node[fill=white]{$\mathfrak{C}$} (v4);
			\path (v5) edge node[left,near start]{$\{c_1,c_3\}$} (v7);
			\path (v7) edge[bend left] node[fill=white]{$\{c_1,c_2\}$} (v6);
			\path (v6) edge[bend left] node[fill=white]{$\{c_1,c_2\}$} (v7);
		\end{tikzpicture}
		\caption{Unified parity game originating from a VPG with configuration $\mathfrak{C} = \{c_1,c_2,c_3\}$}
		\label{fig:upg}
	\end{figure}
We calculate the function-wise attractor set for player 0 from origin vertex $\hat{v}_2$ with all configuration, we have
\[ U^\lambda_0 = U^\lambda = \{\hat{v}_1 \mapsto \emptyset, \hat{v}_2 \mapsto \mathfrak{C}, \hat{v}_3 \mapsto \emptyset, \hat{v}_4 \mapsto \emptyset, \hat{v}_5 \mapsto \emptyset, \hat{v}_6 \mapsto \emptyset, \hat{v}_7 \mapsto \emptyset\}\]
After the first iteration we find
\[U^\lambda_1 = \{\hat{v}_1 \mapsto \mathfrak{C}, \hat{v}_2 \mapsto \mathfrak{C}, \hat{v}_3 \mapsto \mathfrak{C}, \hat{v}_4 \mapsto \emptyset, \hat{v}_5 \mapsto \{c_2\}, \hat{v}_6 \mapsto \emptyset, \hat{v}_7 \mapsto \emptyset\}\]
Note that $\hat{v}_5$ can be attracted for configuration $\{c_2\}$ because $\mathfrak{C} \backslash E^\lambda(\hat{v}_5,\hat{v}_7) = \{c_2\}$, $U^\lambda_0(\hat{v}_3) = \mathfrak{C}$ and for any other origin vertex $\hat{v}$ we have $\mathfrak{C} \backslash E^\lambda(\hat{v}_5,\hat{v}) = \mathfrak{C}$.

In the next iteration we find
\[U^\lambda_2 = \{\hat{v}_1 \mapsto \mathfrak{C}, \hat{v}_2 \mapsto \mathfrak{C}, \hat{v}_3 \mapsto \mathfrak{C}, \hat{v}_4 \mapsto \{c_1,c_2\}, \hat{v}_5 \mapsto \{c_2\}, \hat{v}_6 \mapsto \{c_3\}, \hat{v}_7 \mapsto \emptyset\}\]

Next iterations result in the same function, so $0\textit{-FAttr}(G,U^\lambda) = U^\lambda_2$. We create subgame $G\backslash U^\lambda_2$ depicted in Figure \ref{fig:upg_subattr}.
\begin{figure}[h]
	\centering\begin{tikzpicture}[->]
		\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
		\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
		
		\node[odd, label={north:$\hat{v}_1\ |\ \emptyset$}] (v1) at (20,20) {5};
		\node[even,label={north:$\hat{v}_2\ |\ \emptyset$}] (v2) at (23,20) {6};
		\node[even,label={north:$\hat{v}_3\ |\ \emptyset$}] (v3) at (26,20) {4};
		
		\node[even,label={north:$\hat{v}_4\ |\ \{c_3\}$}]  (v4) at (20,17) {1};
		\node[odd, label={north:$\hat{v}_5\ |\ \{c_1,c_3\}$}] (v5) at (23,17) {2};
		\node[odd, label={north:$\hat{v}_6\ |\ \{c_1,c_2\}$}] (v6) at (26,17) {3};
		
		\node[odd, label={south:$\hat{v} _7\ |\ \mathfrak{C}$}] (v7) at (23,14) {2};
		
		\path (v4) edge node[fill=white]{$\{c_3\}$} (v5);
		
		
		\path (v7) edge node[fill=white]{$\{c_3\}$} (v4);
		\path (v5) edge node[left,near start]{$\{c_1,c_3\}$} (v7);
		\path (v7) edge[bend left] node[fill=white]{$\{c_1,c_2\}$} (v6);
		\path (v6) edge[bend left] node[fill=white]{$\{c_1c_2\}$} (v7);
		\path (v6) edge node[fill=white]{$\{c_1\}$} (v5);
	\end{tikzpicture}
	\caption{Unified parity game $G \backslash U^\lambda_2$}
	\label{fig:upg_subattr}
\end{figure}

\end{example}


In the next two lemma's we show that the function-wise attractor and subgame operators give results that are equal to the original attractor and subgame operators.
\begin{lemma}
	\label{lem_attr_equal}
	Given:
	\begin{itemize}
		\item unified parity game $G = ({V},\hat{V}_0,\hat{V}_1, {E}, \hat{\Omega})$,
		\item set ${U} \subseteq {V}$, and
		\item function $U^\lambda$ such that $U =_\lambda U^\lambda$
	\end{itemize}
it holds that the function-wise attractor $\alpha\textit{-FAttr}(G,{U^\lambda})$ is equivalent to the set-wise attractor $\alpha\textit{-Attr}(G,{U})$ for any $\alpha \in \{0,1\}$.
	\begin{proof}
		Let $V$ and $E$ be the set-wise representation of the vertices and edges for game $G$. Let $V^\lambda$ and $E^\lambda$ be the function-wise representation of the vertices and edges for game $G$.
		
		The following properties hold by definition:
		\[ (c,\hat{v}) \in V \iff c \in V^\lambda(\hat{v})\]
		\[ (c,\hat{v}) \in U \iff c \in U^\lambda(\hat{v})\]
		\[ ((c,\hat{v}),(c,\hat{v}')) \in E \iff c \in E^\lambda(\hat{v},\hat{v}') \]
		
		Since the attractors are inductively defined and $U_0 =_\lambda U^\lambda_0$ (because $U =_\lambda U^\lambda$) we have to prove that for some $i \geq 0$, with $U_i =_\lambda U^\lambda_i$,  we have $U_{i+1} =_\lambda U^\lambda_{i+1}$, which holds iff:
		\[ (c,\hat{v}) \in U_{i+1} \iff c \in U^\lambda_{i+1}(\hat{v}) \]
		Let $(c,\hat{v}) \in V$ (and therefore $c \in V^\lambda(\hat{v})$), we consider 4 cases.
		\begin{itemize}
			\item Case: $\hat{v} \in \hat{V}_{\alpha}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. If $(c,\hat{v}) \notin U_i$ then we have $c \notin U^\lambda_i(\hat{v})$.
			
			
			Because $\hat{v} \in \hat{V}_{\alpha}$ and $c \in V^\lambda(\hat{v})$ we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			There exists an $(c',\hat{v}') \in V$ such that $(c',\hat{v}') \in U_i$ and $((c,\hat{v}),(c',\hat{v}')) \in E$. Because edges do not cross configurations we can conclude that $c' = c$. Due to equivalence we have $c \in U^\lambda_i(\hat{v}')$ and $c \in E^\lambda(\hat{v},\hat{v}')$. If we fill this in in the above formula we can conclude that $c \in U^\lambda_{i+1}(\hat{v})$.
			\item Case: $\hat{v} \in \hat{V}_{\alpha}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			
			First we observe that since $(c, \hat{v}) \notin U_{i+1}$ we get $(c, \hat{v}) \notin U_{i}$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			Because $\hat{v} \in \hat{V}_{\alpha}$ and $c \in V^\lambda(\hat{v})$ we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			Assume $c \in U^\lambda_{i+1}(\hat{v})$. There must exist a $\hat{v}'$ such that $c \in E^\lambda(\hat{v},\hat{v}')$ and $c \in U^\lambda_i(\hat{v}')$. Due to equivalence we have a vertex $((c,\hat{v}),(c,\hat{v}')) \in E$ and $(c,\hat{v}') \in U_i$. In which case $(c,\hat{v})$ would be attracted and would be in $U_{i+1}$ which is a contradiction.
			\item Case: $\hat{v} \in \hat{V}_{\overline{\alpha}}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. If $(c,\hat{v}) \notin U_i$ then we have $c \notin U^\lambda_i(\hat{v})$.
			
			Because $\hat{v} \in \hat{V}_{\overline{\alpha}}$ we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \]
			
			Assume $c \notin U^\lambda_{i+1}(\hat{v})$. Because $c \in V^\lambda(\hat{v})$ there must exist an $\hat{v}$ such that
			\[ c \notin ((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			which is equal to
			\[ c \in E^\lambda(\hat{v},\hat{v}') \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			By equivalence we have $((c,\hat{v}),(c,\hat{v}')) \in E$ and $(c,\hat{v}') \notin U_i$. Which means that $(c,\hat{v})$ will not be attracted and $(c,\hat{v}) \notin U_{i+1}$ which is a contradiction.
			\item Case: $\hat{v} \in \hat{V}_{\overline{\alpha}}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			First we observe that since $(c, \hat{v}) \notin U_{i+1}$ we get $(c, \hat{v}) \notin U_{i}$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			Because $\hat{v} \in \hat{V}_{\overline{\alpha}}$ we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \]
			
			Since $(c,\hat{v})$ is not attracted there must exist a $(c,\hat{v}') \in V$ such that 
			\[ ((c,\hat{v}),(c,\hat{v}')) \in E  \text{ and } (c,\hat{v}') \notin U_i \]
			By equivalence we have 
			\[ c \in E^\lambda(\hat{v},\hat{v}')  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			Which is equal to
			\[ c \notin (\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}'))  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			From which we conclude
			\[ c \notin ((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}'))) \]
			Therefore we have $c \notin U^\lambda_{i+1}(\hat{v})$.
		\end{itemize}
	\end{proof}
\end{lemma}

\begin{lemma}
	\label{lem_subgame_eq}
	Given:
	\begin{itemize}
		\item unified parity game $G = ({V},\hat{V}_0,\hat{V}_1, \mathcal{E}, \hat{\Omega})$,
		\item set ${U} \subseteq V$ and
		\item function $U^\lambda$ such that $U =_\lambda U^\lambda$
	\end{itemize}
it holds that the subgame $G \backslash {U} = ({V}',\hat{V}_0,\hat{V}_1,{E}',\hat{\Omega})$ represented set-wise is equal to the subgame $G\backslash U^\lambda$ represented function-wise.
	\begin{proof}
		Let  $V^\lambda,{V'}^\lambda, E^\lambda, {E^\lambda}'$ the function-wise representations of $V,V',E,E'$ respectively. We know $V =_\lambda V^\lambda$, $E =_\lambda E^\lambda$ and $U =_\lambda U^\lambda$. To prove: $V' =_\lambda {V'}^\lambda$ and $E' =_\lambda {E^\lambda}'$.
		
		\begin{enumerate}
			\item Let $(c,\hat{v}) \in V$.
			
			If $(c,\hat{v}) \in U$ then $c \in U^\lambda(\hat{v})$, also $(c,\hat{v}) \notin V'$ (by Definition \ref{def_org_subgame}) and $c \notin {V'}^\lambda(\hat{v})$ (by Definition \ref{def_Usubgame}).
			
			If $(c,\hat{v}) \notin U$ then $c \notin U^\lambda(\hat{v})$, also $(c,\hat{v}) \in V'$ (by Definition \ref{def_org_subgame}) and $c \in {V'}^\lambda(\hat{v})$ (by Definition \ref{def_Usubgame}).
			
			We conclude that $V' =_\lambda {V'}^\lambda$.
			\item 
			
			Let $((c,\hat{v}),(c,\hat{w})) \in E$.
			
			If $(c,\hat{v}) \in U$ then $(c,\hat{v}) \notin V'$ and $c \notin {V'}^\lambda(\hat{v})$ (as shown above). We get $((c,\hat{v}),(c,\hat{w})) \notin V' \times V'$ so $((c,\hat{v}),(c,\hat{w})) \notin E'$ (by Definition \ref{def_org_subgame}). Also $c \notin {E^\lambda}'(\hat{v},\hat{w})$ (by Definition \ref{def_Usubgame}).
			
			If $(c,\hat{w}) \in U$ then we apply the same logic.
			
			If neither is in $U$ then both are in $V'$ and in $V' \times V'$ and therefore the $((c,\hat{v}),(c,\hat{w})) \in E'$. Also we get $c \in {V'}^\lambda(\hat{v})$ and $c \in {V'}^\lambda(\hat{w})$ so we get $c \in {E^\lambda}'(\hat{v},\hat{w})$ (by Definition \ref{def_Usubgame}).
			
			We conclude that $E' =_\lambda {E^\lambda}'$.
		\end{enumerate}
	\end{proof}
\end{lemma}

Next we prove the correctness of the algorithm by showing that the winning sets of the function-wise algorithm are equal to the winning sets of the set-wise algorithm.
\begin{theorem}
	Given unified parity game ${G} = ({V},\hat{V}_0,\hat{V}_1, {E}, \hat{\Omega})$ and $G^\lambda = (V^\lambda, \hat{V}_0, \hat{V}_1, E^\lambda,\hat{\Omega})$ which is the functional representation of $G$. It holds that the winning sets resulting from \textsc{RecursiveUPG(${G}^\lambda$)} are equal to the winning sets resulting from \textsc{RecursivePG(${G}$)}.
	\begin{proof}
		Proof by induction on $G$.
		
		\textbf{Base}: When there are no vertices then \textsc{RecursiveUPG($G^\lambda$)} returns $(\lambda^\emptyset,\lambda^\emptyset)$ and \textsc{RecursivePG($G$)} returns $(\emptyset,\emptyset)$, these two results are equal therefore the theorem holds in this case.
		
		\textbf{Step}: Player $\alpha$ gets the same value in both algorithms since the highest priority is equal for both algorithms.
		
		Let $U = \{(c,\hat{v}) \in V\ |\ \hat{\Omega}(\hat{v}) = h \}$ (as calculated by \textsc{RecursivePG}) and $U^\lambda(\hat{v}) = V^\lambda(\hat{v})$ for all $\hat{v}$ with $\hat{\Omega}(\hat{v}) = h$ (as calculated by \textsc{RecursiveUPG}). We will show that $U =_\lambda U^\lambda$.
		
		Let $(c,\hat{v}) \in U$. Then $\hat{\Omega}(\hat{v}) = h$ and therefore $U^\lambda(\hat{v}) = V^\lambda(\hat{v})$. Since $U \subseteq V$ we have $(c,\hat{v}) \in V$ and because the equality between $V$ and $V^\lambda$ we get $c \in V^\lambda(\hat{v})$ and $c \in U^\lambda(\hat{v})$.
		
		Let $c \in U^\lambda(\hat{v})$, since $U^\lambda(\hat{v})$ is not empty we have $\hat{\Omega}(\hat{v}) = h$, furthermore $c \in V^\lambda(\hat{v})$ and therefore $(c,\hat{v}) \in V$. We can conclude that $(c, \hat{v}) \in U$ and $U =_\lambda U^\lambda$.
		
		For the rest of the algorithm it is sufficient to see that attractor sets are equal if the game and input set are equal (as shown in Lemma \ref{lem_attr_equal}) and that the created subgames are equal (as shown in Lemma \ref{lem_subgame_eq}). Since the subgames are equal we can apply the theorem on it by induction and conclude that the winning sets are also equal.
	\end{proof}
\end{theorem}

Theorem \ref{the_winning_set_is_equal_to_proj_winning_set} shows that solving a unified parity game solves the VPG, furthermore the algorithm \textsc{RecursiveUPG} correctly solves a unified parity game. Therefore, we can conclude that for VPG $\hat{G}$ vertex $\hat{v}$ is won by player $\alpha$ for configuration $c$ if and only if $c \in W_\alpha^\lambda(\hat{v})$ with $(W^\lambda_0,W^\lambda_1) = \textsc{RecursiveUPG}(G_{\downarrow})$.

\subsubsection{Function-wise attractor set}
Next we present an algorithm to calculate the function-wise attractor, the pseudo code is presented in Algorithm \ref{alg_fattr_alg}. The algorithm considers vertices that are in the attractor set for some configuration. For every such vertex the algorithm tries to attract vertices that are connected by an incoming edge. If a vertex is attracted for some configuration then the incoming edges of that vertex will also be considered.
\begin{algorithm}
	\caption{$\textsc{$\alpha$-FAttractor}(G, U^\lambda : \hat{V} \rightarrow 2^\mathfrak{C})$}\label{alg_fattr_alg}
	\begin{algorithmic}[1]
		\State $A^\lambda \gets U^\lambda$
		\State Queue $Q \gets \{\hat{v} \in \hat{V} \ |\ U^\lambda(\hat{v}) \neq \emptyset  \}$
		\While{$Q$ is not empty}\label{line:fattr:while}
		\State $\hat{v}' \gets Q.pop()$\label{line:fattr:pop}
		\For{every $\hat{v}$ such that $E^\lambda(\hat{v},\hat{v}') \neq \emptyset$}\label{line:fattr:firstfor}
			\If{$\hat{v} \in \hat{V}_\alpha$}\label{line:fattr:if_owner_alpha}
				\State $a \gets V^\lambda(\hat{v}) \cap E^\lambda(\hat{v},\hat{v}') \cap A^\lambda(\hat{v}')$\label{line:fattr:attract_owner_alpha}
			\Else
				\State $a \gets V^\lambda(\hat{v})$\label{line:fattr:attract_owner_not_alpha_start}
				\For{every $\hat{v}''$ such that $E^\lambda(\hat{v},\hat{v}'') \neq \emptyset$}
					\State $a \gets a \cap ((\mathfrak{C}\backslash E^\lambda(\hat{v},\hat{v}'')) \cup A^\lambda(\hat{v}''))$
				\EndFor\label{line:fattr:attract_owner_not_alpha_end}
			\EndIf\label{line:fattr:if_owner_alpha_end}
			\If{$a \backslash A^\lambda(\hat{v}) \neq \emptyset$}\label{line:fattr:if_something_attracted}
				\State $A^\lambda(\hat{v}) \gets A^\lambda(\hat{v}) \cup a$\label{line:fattr:add_to_A}
				\State $Q.push(\hat{v})$\label{line:fattr:add_to_Q}
			\EndIf
		\EndFor
		\EndWhile
		\State \Return $A^\lambda$
	\end{algorithmic}
\end{algorithm}

We prove that the result calculated by $\alpha\textsc{-Fattractor}$ is equal to the definition of $\alpha\textit{-FAttr}$ (Definition \ref{def_Uattr}). 

\begin{theorem}
Given unified parity game $G = (V^\lambda, \hat{V}_0,\hat{V}_1,E^\lambda,\hat{\Omega})$, represented function-wise, and $U^\lambda \subseteq V^\lambda$, the algorithm $\alpha$-\textsc{FAttractor}$(G, U^\lambda)$ correctly calculates $\alpha\textit{-FAttr}(G,U^\lambda)$.
	\begin{proof}\ 
		
		\textit{Termination}. First note that the algorithm terminates. This follows from the fact that only vertices are added to $Q$ (line \ref{line:fattr:add_to_Q}) when something is added to $A^\lambda$ (lines \ref{line:fattr:if_something_attracted} - \ref{line:fattr:add_to_A}). This can only happen finitely many times before $A^\lambda(\hat{v}) = \mathfrak{C}$ for every $\hat{v}$, so $Q$ is empty after finitely many steps.
		
		\textit{Soundness}. To prove the soundness of the algorithm we must show that at the end of the algorithm we have for every $c\in A^\lambda(\hat{w})$ that $c \in \alpha$-\textsc{FAttractor}$(G, U^\lambda)(\hat{w})$. This property actually holds throughout the entire algorithm. Before the while loop (line \ref{line:fattr:while}) we have $A^\lambda = U^\lambda$ and the property holds trivially. Consider the beginning of a while loop iteration (the algorithm is on line \ref{line:fattr:pop}) and assume that the property holds. The algorithm considers a number of vertices in the first for loop (line \ref{line:fattr:firstfor}), let $\hat{v}$ be such a vertex. The algorithm calculates $a \subseteq \mathfrak{C}$, which is added to $A^\lambda(\hat{v})$ on line \ref{line:fattr:add_to_A}. Note that this is the only place in the while loop where $A^\lambda$ is modified. The value calculated for $a$ on lines \ref{line:fattr:if_owner_alpha}-\ref{line:fattr:if_owner_alpha_end} exactly reflects the definition of $\alpha\textit{-FAttr}$ (Definition \ref{def_Uattr}). Because we assumed that the property holds at the beginning of the while loop iteration we can conclude that $a \subseteq \alpha\textit{-FAttr}(G,U^\lambda)(\hat{v})$. We conclude that the property is maintained during the while loop and that it holds at the end of the algorithm.
		
		\textit{Completeness}. To prove completeness we consider $c \in \alpha\textit{-FAttr}(G,U^\lambda)(\hat{w})$ and show that $c \in \alpha$-\textsc{FAttractor}$(G, U^\lambda)(\hat{w})$.
		
		Consider the values for $U^\lambda_i$ for $\alpha\textit{-FAttr}(G,U^\lambda)$ as defined in Definition \ref{def_Uattr}. It is clear that for some $i \geq 0$ we have $c \in U^\lambda_i(\hat{w})$, however not necessarily for all $i \geq 0$.	Let $i \geq 0$ such that $c \in U^\lambda_i(\hat{w})$ and either $i=0$ or $c \notin U^\lambda_{i-1}(\hat{w})$.
		
		We apply induction on $i$, to show that at some point during the algorithm we have $c \in A^\lambda(\hat{w})$ and $\hat{w} \in Q$. Note that $A^\lambda(\hat{w})$ never decreases during the algorithm, so by proving this we get completeness.
		
		\textbf{Base} $i=0$: In this case $c \in U^\lambda(\hat{w})$ and in the first two lines of the algorithm we find $c \in A^\lambda(\hat{w})$ and $\hat{w}$ in $Q$.
		
		\textbf{Step} $i > 0$: We distinguish two cases:
		\begin{itemize}
			\item If $\hat{w} \in \hat{V}_\alpha$ then there exists a $\hat{w}'$ such that $c \in E^\lambda(\hat{w},\hat{w}')$ and $c \in U^\lambda_{i-1}(\hat{w}')$. We apply induction on $w'$ to find that at some point $c \in A^\lambda(\hat{w}')$ and $\hat{w}'$ is in $Q$. So at some point, the algorithm pops $\hat{w}'$ from $Q$ (line \ref{line:fattr:pop}) and we have $c \in A^\lambda(\hat{w}')$. Because $c \in E^\lambda(\hat{w},\hat{w}')$ the first for loop (line \ref{line:fattr:firstfor}) considers vertex $\hat{w}$ and on line \ref{line:fattr:attract_owner_alpha} we get $c \in a$. 
		
			If at this point we do not already have $c \in A^\lambda(\hat{w})$ then we get $c \in A^\lambda(\hat{w})$ on line \ref{line:fattr:add_to_A} and $\hat{w}$ is added to $Q$ on line \ref{line:fattr:add_to_Q}. If we already had $c \in A^\lambda(\hat{w})$ then $c$ had to be added to $A^\lambda(\hat{w})$ on line \ref{line:fattr:add_to_A} (because $i > 0$ this could not have been done in the first two lines) and $\hat{w}$ would also be added to $Q$ on line \ref{line:fattr:add_to_Q}. So the induction hypothesis holds in this case.
			
			\item If $\hat{w} \in \hat{V}_{\overline{\alpha}}$ then for every $\hat{w}'$ with $c \in E^\lambda(\hat{w},\hat{w}')$ we get $c \in U^\lambda_{i-1}(\hat{w}')$, we call these vertices the successors of $\hat{w}$ for configuration $c$. We apply induction on every successor $\hat{w}'$ of $\hat{w}$ for $c$ to find that at some point $c \in A^\lambda(\hat{w}')$ and $\hat{w}'$ is in $Q$. So at some point, the algorithm pops successor $\hat{w}''$ from $Q$ (line \ref{line:fattr:pop}) and we have $c \in A^\lambda(\hat{w}')$ for all successor $\hat{w}'$ of $\hat{w}$ for $c$. Because $c \in E^\lambda(\hat{w},\hat{w}'')$ the first for loop (line \ref{line:fattr:firstfor}) considers vertex $\hat{w}$ and on lines \ref{line:fattr:attract_owner_not_alpha_start}-\ref{line:fattr:attract_owner_not_alpha_end} we get $c \in a$. 
			
			If at this point we do not already have $c \in A^\lambda(\hat{w})$ then we get $c \in A^\lambda(\hat{w})$ on line \ref{line:fattr:add_to_A} and $\hat{w}$ is added to $Q$ on line \ref{line:fattr:add_to_Q}. If we already had $c \in A^\lambda(\hat{w})$ then $c$ had to be added to $A^\lambda(\hat{w})$ on line \ref{line:fattr:add_to_A} (because $i > 0$ this could not have been done in the first two lines) and $\hat{w}$ would also be added to $Q$ on line \ref{line:fattr:add_to_Q}. So the induction hypothesis holds in this case.
		\end{itemize}
		
	\end{proof}
\end{theorem}

\subsection{Running time}
We consider the running time for solving VPG $\hat{G} = (\hat{V},\hat{V}_0,\hat{V}_1,\hat{E},\hat{\Omega},\mathfrak{C},\theta)$ independently and collectively using the different types of representations. We use $n$ to denote the number of vertices, $e$ the number of edges, $d$ the number of distinct priorities and $c$ the number of configurations.

The original algorithm runs in $O(e * n^d)$ \cite{friedmanPG}, if we run $c$ parity games independently we get $O(c * e * n ^d)$. We can also apply the original algorithm to a unified parity game (represented set-wise) for a collective approach, in this case we get a parity game with $c*n$ vertices and $c*e$ edges. which gives a time complexity of $O(c*e*(c*n)^d)$. However, as we show next, this upper bound can be improved by using the property that a unified parity game consists of $c$ disconnected graphs.

We have introduced three types of collective algorithms: set-wise, function-wise with explicit configuration sets and function-wise with symbolic configuration sets. In all three algorithms the running time of the attractor set dominates the other operations performed, so we need three things: analyse the running time of the base cases, analyse the running time of the attractor set and analyse the recursion.

\subsubsection{Base cases} In the base cases the algorithm needs to check if there are no more vertices in the game. For the set-wise variant this is done in $O(1)$. For the function wise algorithms this is done in $O(n)$ since we have to check $V(\hat{v}) = \emptyset$ for every $\hat{v}$. Note that in a symbolic representation using BDDs we can check if a set is empty in $O(1)$ because the decision diagram contains a single node when representing an empty set.

\subsubsection{Attractor sets} For the set-wise collective approach we can use the attractor calculation from the original algorithm which has a time complexity of $O(e)$ \cite{Kant2013PracticalIT}. So for a unified parity game having $c*e$ edges we have $O(c*e)$.

The function-wise variants use a different attractor algorithm. First we consider the variant where sets of configurations are represented explicitly.

Consider Algorithm \ref{alg_fattr_alg}. A vertex will be added to the queue when this vertex is attracted for some configuration, this can only happen $c*n$ times, once for every vertex-configuration combination. 


During an iteration of the while loop, the first for loop considers all vertices with an edge to the vertex under consideration by the while loop. We note that during one iteration of the while loop the first for loop never considers a vertex twice. Because of this we can also conclude that during one iteration of the while loop the second for loop considers no edge twice. Since the while loop runs at most $c*n$ times and in every iteration the second for loop considers at most $e$ edges, we conclude that the second for loop runs at most $c*n*e$ times. 

The second for loop performs set operations on the set of configurations which can be done in $O(c)$ using an explicit representation. This gives a total time complexity for the attractor set of $O(n*c^2*e)$.

Symbolic set operations can be done in $O(c^2)$ so we get a time complexity of $O(n*c^3*e)$.

This gives the following time complexities\\
\begin{center}
	\begin{tabular}{|c|c|c|}
		\hline 
		& Base & Attractor set \\ 
		\hline 
		Set-wise & $O(1)$ & $O(c*e)$  \\ 
		\hline 
		Function-wise explicit & $O(n)$ &  $O(n*c^2*e)$ \\ 
		\hline 
		Function-wise symbolic & $O(n)$ &  $O(n* c^3*e)$ \\ 
		\hline 
	\end{tabular} 
\end{center}

\subsubsection{Recursion} The three algorithms behave the same way with regards to their recursion, so we analyse the recursion for all three algorithms at the same time. Let $O_B$ denote the time complexity of the base case for the algorithm and let $O_A$ denote the time complexity of the attractor set. For all variants of the algorithm we have $O_B \leq O_A$ and $O_A + O_B = O_A$.

The algorithm has two recursions. The first recursion lowers the number of distinct priorities by 1. The second recursion removes at least one vertex. However the game is comprised of disjoint projections. We can use this fact in the analyses. Consider unified parity game $G$ and set $A$ as specified by the algorithm. Now consider the projection of $G$ to an arbitrary configuration $q$, $G_{|q}$. If $(G\backslash A)_{|q}$ contains a vertex that is won by player $\overline{\alpha}$ then this vertex is removed in the second recursion step. If there is no vertex won by player $\overline{\alpha}$ then the game is won in its entirety and the only vertices won by player $\overline{\alpha}$ are in different projections. We can conclude that for every configuration $q$ the second recursion either removes a vertex or $(G\backslash A)_{|q}$ is entirely won by player $\alpha$. Let $\bar{w}$ denote the maximum number of vertices that are won by player $\overline{\alpha}$ in game $(G\backslash A)_{|q}$. Since every projection has at most $n$ vertices the value for $\bar{w}$ can be at most $n$. Furthermore since $\bar{w}$ depends on $A$, which depends on the maximum priority, the value $\bar{w}$ gets reset when the top priority is removed in the first recursion. We can now write down the recursion of the algorithm:
\[ T(d,\bar{w}) \leq T(d-1,n) + T(d, \bar{w} - 1) + O_A \]
When $\bar{w} = 0$ we will get $W_{\overline{\alpha}} = \emptyset$ as a result of the first recursion. In such a case there will be only 1 recursion.
\[ T(d,0) \leq T(d-1,n) + O_A \]
Finally we have the base cases. If $d=0$ then there are no vertices and we have the base time complexity.
\[ T(0,\overline{w}) \leq O_B \]
If $d=1$ then all the vertices have the same priority, therefore the first subgame created is empty and entirely won by player $\alpha$. So we never go in the second recursion.
\[ T(1,\overline{w}) \leq T(0,n) + O_A \leq O_B + O_A = O_A \]
Expanding the second recursion gives
\begin{align*}
T(d) &\leq (n+1)T(d-1) + (n+1)O_A\\
T(1) &\leq O_A
\end{align*}
We prove that $T(d) \leq (n+d)^dO_A$ by induction on $d$.

\textbf{Base} $d=1$: $T(1) \leq O_A \leq (n+1)^1O_A$

\textbf{Step} $d > 1$:
\begin{align*}
T(d) &\leq (n+1)T(d-1) + (n+1)O_A\\
&\leq (n+1)(n+d-1)^{d-1}O_A + (n+1)O_A
\end{align*}
Since $n+1 \leq n+d-1$ we get:
\begin{align*}
T(d) &\leq (n+d-1)(n+d-1)^{d-1}O_A + (n+1)O_A\\
&\leq ((n+d-1)(n+d-1)^{d-1}+n+1)O_A\\
&\leq (n(n+d-1)^{d-1} + d(n+d-1)^{d-1} - (n+d-1)^{d-1} + n +1)O_A\\
&\leq (n(n+d)^{d-1} + d(n+d)^{d-1} - (n+d-1)^{d-1} + n +1)O_A\\
\end{align*}
Because $(n+d-1)^{d-1} \geq n+1$ we have $ - (n+d-1)^{d-1} + n +1 \leq 0$, therefore:
\begin{align*}
T(d) &\leq (n(n+d)^{d-1} + d(n+d)^{d-1})O_A\\
&\leq (n+d)(n+d)^{d-1}O_A\\
&\leq (n+d)^{d}O_A\\
\end{align*}
This gives a time complexity of $O(O_A*(n+d)^d) = O(O_A*n^d)$ because $n \geq d$. Filling in values for $O_A$ gives the following time complexities:\\
\begin{center}
	\begin{forest}
	[Recursive algorithm, for tree={parent anchor=south, child anchor=north, align=center, s sep=5mm}
		[Independent\\$O(c*e*n^d)$ ]
		[Collective
			[Set-wise\\$O(c*e*n^d)$ ]
			[Function-wise
				[Explicit\\$O(n * c^2 * e * n^d)$ ]
				[Symbolic\\$O(n * c^3 * e * n^d)$ ]
			]
		]
	]
	\end{forest}
\end{center}

\subsubsection{Running time in practice}
Earlier we hypothesized that the symbolic function-wise algorithm could have the best performance of the 4 algorithms, however it has the worst time complexity. Our hypothesis is based on the notion that VPGs most likely have a lot of commonalities and that sets of configurations in the VPG can be represented efficiently symbolically. Next we argue why the worst-case time complexity might not represent the running time in practice.

We dissect the running time of the function-wise algorithms. The running time complexities of the collective algorithms consist of two parts: the time complexity of the attractor set times $n^d$. The function-wise attractor set time complexity consists of three parts: the number of edges times the maximum number of vertices in the queue ($c*n$) times the time complexity for set operations ($O(c)$ for the explicit variant, $O(c^2)$ for the symbolic variant).

The number of vertices in the queue during attracting is at most $c*n$, however this number will only be large if we attract a very small number of configurations per time we evaluate an edge. As argued earlier we can most likely attract multiple configurations at the same time. This will decrease the number of vertices in the queue.

The time complexity of set operations is $O(c)$ when using an explicit representation and $O(c^2)$ when using a symbolic one. However, as shown in \cite{BDD_running_time}, we can implement BDDs to keeps a table of already computed results. This allows us to get already calculated results in sublinear time. In total there are $2^c$ possible sets and therefore $2^{2c}$ possible set combinations and $O(2^c)$ possible set operations that can be computed. However when solving a VPG originating from an FTS there will most likely be a relatively small number of different edge guards, in which case the number of unique sets considered in the algorithm will be small and we can often retrieve a set calculation from the computed table.

We can see that even though the running time of the collective symbolic algorithm is the worse, its practical running time might be good when we are able to attract multiple configurations at the same time and have a small number of different edge guards.