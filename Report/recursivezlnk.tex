\subsubsection{Original Zielonka's recursive algorithm}
The original Zielonka's recursive algorithm, created from the constructive proof given in \cite{ZIELONKA1998135}, is defined for a total PG (ie. an infinite game). We have a few definitions that are relevant for the algorithm.
\begin{algorithm}[h]
	\caption{$\textsc{RecursivePG}(\textit{PG } G = (V,V_0,V_1, E, \Omega))$}
	\begin{algorithmic}[1]
		\State $m \gets \min\{ \Omega(v)\ |\ v \in V\}$
		\State $h \gets\max\{ \Omega(v)\ |\ v \in V\}$
		\If{$h = m$ or $V = \emptyset$}
		\If{$h$ is even or $V = \emptyset$}
		\State \Return $(V,\emptyset)$
		\Else
		\State \Return $(\emptyset, V)$
		\EndIf
		\EndIf
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{v \in V\ |\ \Omega(v) = h\}$
		\State $A \gets \alpha\textit{-Attr}(G, U)$
		\State $(W_0', W_1') \gets \textsc{RecursivePG}(G \backslash A)$
		\If{$W_{\overline{\alpha}}' =\emptyset$}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-Attr}(G,W_{\overline{\alpha}}')$
		\State $(W_0'', W_1'') \gets \textsc{RecursivePG}(G \backslash B)$
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}

\begin{definition}\cite{ZIELONKA1998135}
	\label{def_attr}Given parity game $G = (V,V_0,V_1,E,\Omega)$ and a non-empty set $U \subseteq V$ we define $\alpha\textit{-Attr}(G,U)$ such that
	\[U_0 = U \]
	For $i \geq 0$:
	\begin{align*}
	U_{i+1} = U_i\cup
	&\{v \in V_\alpha\ |\ \exists v' \in V : v' \in U_i \wedge (v,v') \in E \}\\
	\cup &\{v \in V_{\overline{\alpha}}\ |\ \forall v' \in V :(v,v') \in E \implies v' \in U_i \}
	\end{align*}
	\[\alpha\textit{-Attr}(G,U) = U_k \]
	such that for $k$ we have
	\[U_k = U_{k+1} \]
\end{definition}
\begin{definition}\cite{ZIELONKA1998135}
\label{def_org_subgame}
Given a parity game $G = (V,V_0,V_1, E,\Omega)$ and $U \subseteq V$ we define the subgame $G \backslash U$ to be the game $(V', V_0', V_1', E', \Omega)$ with:
\begin{itemize}
	\item $V' = V \backslash U$,
	\item $V_0' = V_0 \cap V'$,
	\item $V_1' = V_1 \cap V'$ and
	\item $E' = E \cap (V' \times V')$.
\end{itemize}
\end{definition}

We can relax the subgame definition, to a definition where we only remove vertices and not remove edges.
\begin{definition}
	\label{def_relaxed_subgame}
	Given a parity game $G = (V,V_0,V_1, E,\Omega)$ and $U \subseteq V$ we define the relaxed subgame $G \backslash U$ to be the game $(V', V_0', V_1', ', \Omega)$ with:
	\begin{itemize}
		\item $V' = V \backslash U$,
		\item $V_0' = V_0 \cap V'$ and
		\item $V_1' = V_1 \cap V'$.
	\end{itemize}
\end{definition}
We will show that using the relaxed subgame definition in the recursive algorithm gives the same result.
\begin{lemma}
	Using the relaxed subgame (\ref{def_relaxed_subgame}) definition in the recursive algorithm gives the same result as using the regular subgame definition (\ref{def_org_subgame}).
	\begin{proof}
		Let $E$ be the edge relation resulting from a regular subgame operation and $E'$ be the edge relation resulting from a relaxed subgame operation.
		
		We first observe that the difference between the two definitions is that in $E$ only edges exists that go from and go to vertices that are in $V$. In $E'$ edges can exists that go from and/or go to vertices that are not in $V$. We also find $E \subseteq E'$.
		
		Next we observe that the only place where edges are used in the algorithm is in the calculation of the attractor set. We will show that the attractor set calculated for $E$ is equal to the attractor set calculated for $E'$.
		
		Let $v \in V$, we distinguish two cases:
		\begin{itemize}
			\item Case: $v \in V_\alpha$.
			
			Vertex $v$ will only be attracted if there exists a $v' \in V$ such that there is an edge from $v$ to $v'$. Since $v$ and $v'$ are both in $V$ an edge $(v,v') \in E'$ will also exist in $E$, therefore the result is the same.
			\item Case: $v \in V_{\overline{\alpha}}$.
			
		    Vertex $v$ will only be attracted if all the edges that go to $v' \in V$ are in $U_i$. Since edges that go from $v$ to $v'' \notin V$ are not considered the result for both $E$ and $E'$ will be the same.
		\end{itemize}
	\end{proof}
\end{lemma}

\subsubsection{Recursive algorithm for unified VPGs}
We can modify the recursive algorithm to work with the function representation of vertices and edges introduced in section \ref{sec_unified_pg}.
\begin{algorithm}[h]
	\caption{$\textsc{recursiveUVPG}(\textit{PG } G = (\\
		V : \hat{V} \rightarrow 2^\mathfrak{C},\\
		V_0 : \hat{V} \rightarrow 2^\mathfrak{C},\\
		V_1 : \hat{V} \rightarrow 2^\mathfrak{C},\\
		E : \hat{E} \rightarrow 2^\mathfrak{C},\\
		\Omega : \hat{V} \rightarrow \mathbb{N}))$}
	\begin{algorithmic}[1]
		\State $m \gets \min\{ \Omega(\hat{v})\ |\ V(\hat{v}) \neq \emptyset \}$
		\State $h \gets \max\{ \Omega(\hat{v})\ |\ V(\hat{v}) \neq \emptyset \}$
		\If{$h = m$ or $V(\hat{v}) = \lambda^\emptyset$}
		\If{$h$ is even or $V = \lambda^\emptyset$}
		\State \Return $(V,\lambda^\emptyset)$
		\Else
		\State \Return $(\lambda^\emptyset, V)$
		\EndIf
		\EndIf
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{ \hat{v} |\ V(\hat{v}) \neq \emptyset \wedge \Omega(\hat{v}) = h\}$
		\State $A \gets \alpha\textit{-FAttr}(G, U)$
		\State $(W_0', W_1') \gets \textsc{recursiveUVPG}(G \backslash A)$
		\If{$W_{\overline{\alpha}}' =\lambda^\emptyset$}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \lambda^\emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-FAttr}(G,W_{\overline{\alpha}}')$
		\State $(W_0'', W_1'') \gets \textsc{recursiveUVPG}(G \backslash B)$
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}
We have two modified operators.
\begin{definition}
		\label{def_Uattr}Given unified VPG $G = (V, V_0,V_1,E,\Omega)$, represented function-wise, and a non-empty set $U \subseteq V$ we define $\alpha\textit{-FAttr}(G,U)$ such that
	\[U_0 = U \]
	For $i \geq 0$:
	\[
	U_{i+1}(\hat{v}) = U_i(\hat{v}) \cup \begin{cases}
\bigcup_{\hat{v}'} (V(\hat{v}) \cap E(\hat{v},\hat{v}') \cap U_i(\hat{v}')) & \text{if } V_{\alpha}(\hat{v}) \neq \emptyset \\
V(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E(\hat{v},\hat{v}')) \cup U_i(\hat{v}') \cup (\mathfrak{C}\backslash V(\hat{v}')) & \text{if } V_{\overline{\alpha}}(\hat{v}) \neq \emptyset \\
	\end{cases}
	\]
	\[\alpha\textit{-FAttr}(G,U) = U_k \]
	such that for $k$ we have
	\[U_k = U_{k+1} \]
\end{definition}

\begin{lemma}
	\label{lem_attr_requires_E}
	Vertex $\hat{v}$ with configuration $c$, with $c \in V(\hat{v})$, can only be attracted if there is a vertex $\hat{v}'$ such that $c \in E(\hat{v}, \hat{v}')$ and $c \in U_i(\hat{v}')$.
	\begin{proof}
		We first observe that a v If $V_\alpha(\hat{v}) \neq \emptyset$ then this property follows immediately from definition \ref{def_Uattr}. If $V_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ we note that parity games are total and therefore also total for every configuration (lemma \ref{lem_UVPG_total}), therefore vertex $\hat{v}$ has an outgoing edge to $\hat{w}$ such that $c \in E(\hat{v},\hat{w})$. For $\hat{v}$ with $c$ to be attracted we must have $c \in U_i(\hat{w)}$.
	\end{proof}
\end{lemma}

\begin{definition}
	\label{def_Usubgame}
	For unified VPG $G = (V,V_0,V_1,E,\Omega)$, represented function-wise, and set $X \subseteq V$ we define the subgame $G \backslash X = (V',V_0',V_1',E,\Omega)$ such that:
	\begin{itemize}
		\item $V'(\hat{v}) = V(\hat{v}) \backslash X(\hat{v})$,
		\item $V_0'(\hat{v}) = V'(\hat{v}) \cap V_0(\hat{v})$ and
		\item $V_1'(\hat{v}) = V'(\hat{v}) \cap V_1(\hat{v})$.
	\end{itemize}
\end{definition}

\begin{lemma}
	\label{lem_attr_equal}
	Given unified VPG $G = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ and set $\mathcal{U} \subseteq \mathcal{V}$ the function-wise attractor $\alpha\textit{-FAttr}(G,\mathcal{U})$ is equivalent to the set-wise attractor $\alpha\textit{-Attr}(G,\mathcal{U})$ for any $\alpha \in \{0,1\}$.
	\begin{proof}
		Let $V,V_0,V_1,E,U$ be the set-wise representation and $V^\lambda,V_0^\lambda,V_1^\lambda,E^\lambda,U^\lambda$ be the function-wise representation of $\mathcal{V},\mathcal{V}_0,\mathcal{V}_1,\mathcal{E},\mathcal{U}$ respectively.
		
		The following properties hold by definition:
		\[ (c,\hat{v}) \in X \iff c \in X^\lambda(\hat{v})\text{ for all } X\in \{V,V_0,V_1,U\}\]
		\[ ((c,\hat{v}),(c,\hat{v}')) \in E \iff c \in E^\lambda(\hat{v},\hat{v}') \]
		
		Since the attractors are inductively defined and $U_0$ and $U^\lambda_0$ are equivalent (because $U$ and $U^\lambda$ are equivalent) we have to prove that for some $i \geq 0$, with $U_i$ being equivalent to $U^\lambda_i$, the sets $U_{i+1}$ and $U^\lambda_{i+1}$ are equivalent. The sets $U_{i+1}$ and $U^\lambda_{i+1}$ are equivalent iff:
		\[ (c,\hat{v}) \in U_{i+1} \iff c \in U^\lambda_{i+1}(\hat{v}) \]
		Let $(c,\hat{v}) \in V$, we consider 4 cases.
		\begin{itemize}
			\item Case: $(c, \hat{v}) \in V_{\alpha}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. Consider $(c,\hat{v}) \notin U_i$, we have $c \notin U_i(\hat{v})$.
			
			
			It follows immediately that $c \in V^\lambda_{\alpha}(\hat{v})$ therefore $V^\lambda_{\alpha}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (V^\lambda(\hat{v}) \cap E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			There exists an $(c',\hat{v}') \in V$ such that $(c',\hat{v}') \in U_i$ and $((c,\hat{v}),(c',\hat{v}')) \in E$. Because edges don't cross configurations we can conclude that $c' = c$. Due to equivalence we have $c \in V^\lambda(\hat{v})$, $c \in U^\lambda_i(\hat{v}')$ and $c \in E^\lambda(\hat{v},\hat{v}')$. If we fill this in in the above formula we can conclude that $c \in U^\lambda_{i+1}(\hat{v})$.
			\item Case: $(c, \hat{v}) \in V_{\alpha}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			
			First we observe that $(c,\hat{v}) \notin U_i$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\alpha}(\hat{v})$ therefore $V^\lambda_{\alpha}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =\bigcup_{\hat{v}'} (V^\lambda(\hat{v}) \cap E^\lambda(\hat{v},\hat{v}') \cap U^\lambda_i(\hat{v}')) \]
			
			Assume $c \in U^\lambda_{i+1}(\hat{v})$. There must exist a $\hat{v}'$ such that $c \in V^\lambda(\hat{v})$, $c \in E^\lambda(\hat{v},\hat{v}')$ and $c \in U^\lambda_i(\hat{v}')$. Due to equivalence we have a vertex $(c,\hat{v}) \in V$, $((c,\hat{v}),(c,\hat{v}')) \in E$ and $(c,\hat{v}') \in U_i$. In which case $(c,\hat{v})$ would be attracted and would be in $U_{i+1}$ which is a contradiction.
			\item Case: $(c, \hat{v}) \in V_{\overline{\alpha}}$ and $(c,\hat{v}) \in U_{i+1}$:\\
			To prove: $c \in U^\lambda_{i+1}(\hat{v})$.
			
			If $(c,\hat{v}) \in U_i$ then $c \in U^\lambda_i(\hat{v})$ and therefore $c \in U^\lambda_{i+1}(\hat{v})$. Consider $(c,\hat{v}) \notin U_i$, we have $c \notin U_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\overline{\alpha}}(\hat{v})$ therefore $V^\lambda_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \cup (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			
			Assume $c \notin U^\lambda_{i+1}(\hat{v})$. Because $c \in V^\lambda(\hat{v})$ there must exist an $\hat{v}$ such that
			\[ c \notin ((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \text{ and } c \notin U^\lambda_i(\hat{v}') \text{ and } c \notin (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			which is equal to
			\[ c \in E^\lambda(\hat{v},\hat{v}') \text{ and } c \notin U^\lambda_i(\hat{v}') \text{ and } c \in V^\lambda(\hat{v}') \]
			By equivalence we have $((c,\hat{v}),(c,\hat{v}')) \in E$, $(c,\hat{v}') \notin U_i$ and $(c,\hat{v}') \in V$. Which means that $(c,\hat{v})$ will not be attracted and $(c,\hat{v}) \notin U_{i+1}$ which is a contradiction.
			\item Case: $(c, \hat{v}) \in V_{\overline{\alpha}}$ and $(c,\hat{v}) \notin U_{i+1}$:\\
			To prove: $c \notin U^\lambda_{i+1}(\hat{v})$.
			
			First we observe that $(c,\hat{v}) \notin U_i$ and therefore $c \notin U^\lambda_i(\hat{v})$.
			
			It follows immediately that $c \in V^\lambda_{\overline{\alpha}}(\hat{v})$ therefore $V^\lambda_{\overline{\alpha}}(\hat{v}) \neq \emptyset$ so we get
			\[ U^\lambda_{i+1} =V^\lambda(\hat{v}) \cap \bigcap_{\hat{v'}}((\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup U^\lambda_i(\hat{v}') \cup (\mathfrak{C}\backslash V^\lambda(\hat{v}')) \]
			
			There must exist a $(c,\hat{v}') \in V$ such that 
			\[ ((c,\hat{v}),(c,\hat{v}')) \in E  \text{ and } (c,\hat{v}') \notin U_i \]
			By equivalence we have 
			\[ c \in V^\lambda(\hat{v}')  \text{ and } c \in E^\lambda(\hat{v},\hat{v}')  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			Which is equal to
			\[ c \notin (\mathfrak{C} \backslash V^\lambda(\hat{v}'))  \text{ and } c \notin (\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}'))  \text{ and } c \notin U^\lambda_i(\hat{v}') \]
			From which we conclude
			\[ c \notin ((\mathfrak{C} \backslash V^\lambda(\hat{v}')) \cup c \notin (\mathfrak{C} \backslash E^\lambda(\hat{v},\hat{v}')) \cup c \notin U^\lambda_i(\hat{v}')) \]
			Therefore we have $c \notin U^\lambda_{i+1}(\hat{v})$.
		\end{itemize}
	\end{proof}
\end{lemma}
\begin{lemma}
	\label{lem_subgame_eq}
	Given unified VPG $G = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ and set $\mathcal{U} \subseteq \mathcal{V}$ the function-wise subgame $G \backslash \mathcal{U}$ is equal to the relaxed set-wise subgame $G \backslash \mathcal{U}$.
	\begin{proof}
		Follows immediately from the subgame definitions (\ref{def_relaxed_subgame}, \ref{def_Usubgame}) and the equivalence relation between function-wise and set-wise games.
	\end{proof}
\end{lemma}

\begin{theorem}
	Given unified VPG $\mathcal{G} = (\mathcal{V},\mathcal{V}_0,\mathcal{V}_1, \mathcal{E}, \Omega)$ the winning sets resulting from \textsc{recursiveUVPG($\mathcal{G}$)} ran over the function-wise representation of $G$ is equal to the winning sets resulting from \textsc{RecursivePG($\mathcal{G}$)} ran over the set-wise representation of $G$.
	\begin{proof}
		Let $G = (V,V_0,V_1,E,\Omega)$ be the set-wise representation of $\mathcal{G}$ and $G^\lambda = (V^\lambda, V^\lambda_0, V^\lambda_1, E^\lambda, \Omega)$ be the function-wise representation of $\mathcal{G}$.
		
		Proof by induction on $\mathcal{G}$.
		
		\textbf{Base} $\mathcal{V} = \emptyset$. 
		
		\textsc{recursiveUVPG($G^\lambda$)} returns $\lambda^\emptyset$ and \textsc{RecursivePG($G$)} returns $\emptyset$, these two results are equal therefore the theorem holds in this case.
		
		\textbf{Base} $\min\{\Omega(v)\ |\ v \in \mathcal{V}\} = \max\{\Omega(v)\ |\ v \in \mathcal{V}\}$.
		
		\textsc{recursiveUVPG($G^\lambda$)} returns $\lambda^\emptyset$ and \textsc{RecursivePG($G$)} returns $\emptyset$, these two results are equal therefore the theorem holds in this case.
		
		\textbf{Step}
		
		Player $\alpha$ gets the same value in both algorithms since the highest priority is equal for both algorithms.
		
		Set $\{v \in V\ |\ \Omega(v) = h\}$ is equal to $\{ \hat{v} |\ V(\hat{v}) \neq \emptyset \wedge \Omega(\hat{v}) = h\}$ by equivalence definition. So the values for $U$ are equal in both algorithms.
		
		For the rest of the algorithm it is sufficient to see that attractor sets are equal if the game and input set are equal (as shown in lemma \ref{lem_attr_equal}) and that the created subgames are equal (as shown in lemma \ref{lem_subgame_eq}). Since the subgames are equal we can apply the theorem on it by induction and conclude that the winning sets are also equal.
	\end{proof}
\end{theorem}

We can now conclude that for VPG $\hat{G}$ vertex $\hat{v}$ is won by player $\alpha$ for configuration $c$ iff $c \in W_\alpha(\hat{v})$ with $(W_0,W_1) = \textsc{RecursiveUVPG}(G_{\downarrow})$.

We can implement the function-wise attractor function using a queue to evaluate possibly relevant vertices.
\begin{algorithm}[h]
	\caption{$\textsc{$\alpha$-FAttractor}(G, A : \hat{V} \rightarrow 2^\mathfrak{C})$}
	\begin{algorithmic}[1]
		\State Queue $Q \gets \{\hat{v} \in \hat{V} \ |\ A(\hat{v}) \neq \emptyset  \}$
		\While{$Q$ is not empty}
		\State $\hat{v}' \gets Q.pop()$
		\For{$E(\hat{v},\hat{v}') \neq \emptyset$}
			\If{$A(\hat{v}) = V(\hat{v})$} \State \textbf{continue} \EndIf
			\If{$V_\alpha(\hat{v}) \neq \emptyset$}
				\State $a \gets V(\hat{v}) \cap E(\hat{v},\hat{v}') \cap A(\hat{v}')$
			\Else
				\State $a \gets V(\hat{v})$
				\For{$E(\hat{v},\hat{v}'') \neq \emptyset$}
					\State $a \gets a \cap (\mathfrak{C}\backslash E(\hat{v},\hat{v}'') \cup A(\hat{v}'') \cup \mathfrak{C} \backslash V(\hat{v}''))$
				\EndFor
			\EndIf
			\If{$a = \emptyset$} \State \textbf{continue} \EndIf
			\State $A(\hat{v}) \gets A(\hat{v}) \cup a$
			\State $Q.push(\hat{v})$
		\EndFor
		\EndWhile
		\State \Return $A$
	\end{algorithmic}
\end{algorithm}
\begin{theorem}
Set $A$ calculated by $\textsc{$\alpha$-FAttractor}(G,U)$ satisfies $A = \alpha\textit{-FAttr}(G,U)$.
	\begin{proof} We will prove two loop invariants over the while loop of the algorithm.
		
		\textbf{IV1}: For every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ with $c \in A(\hat{w})$ we have $c \in \alpha\textit{-FAttr}(G,U)(\hat{w})$.
		
		\textbf{IV2}: For every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ that can be attracted to $A$ either $c \in A(\hat{w})$ or there exists a $\hat{w}' \in Q$ such that $c \in E(\hat{w},\hat{w}')$.
		
		\textbf{Base}: Before the loop starts we have $A = U$, therefore IV1 holds. Furthermore all the vertices in $vert(A)$ are in $Q$ so IV2 also holds.
		
		\textbf{Step}: Consider the beginning of an iteration and assume IV1 and IV2 hold. To prove: IV1 and IV2 hold at the end of the iteration.
		
		Set $A$ only contains vertices with configurations that are in $\alpha\textit{-FAttr}(G,U)$. The set is only updated through lines 8-14 and 19 of the algorithm which reflects the exact definition of the attractor set therefore IV1 holds at the end of the iteration as well.
		
		Consider $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$, we distinguish three cases to prove IV2:
		\begin{itemize}
			\item $\hat{w}$ with $c$ can be attracted by the beginning of the iteration but not by the end.
			
			This case can't happen because $A(\hat{w})$ only increases during the algorithm for any $\hat{w}$ and the values for $E$ and $V$ are not changed throughout the algorithm.
			\item $\hat{w}$ with $c$ can't be attracted by the beginning of the iteration but can by the end.
			
			For $\hat{w}$ with $c$ to be able to be attracted at the end of the iteration there must be some $\hat{w}'$ with $c$ such that during the iteration $c$ was added to $A(\hat{w}')$ (lemma \ref{lem_attr_requires_E}). Every $\hat{w}'$ for which $A(\hat{w}')$ is updated is added to the queue (lines 16-20). Therefore there we have $\hat{w}' \in Q$ with $c \in E(\hat{w},\hat{w}')$ and IV1 holds.
			\item $\hat{w}$ with $c$ can be attracted by the beginning of the iteration and also by the end.
			
			Since IV2 holds at the beginning of the iteration we have either $c \in A(\hat{w})$ or we have some $\hat{w}' \in Q$ such that $c \in E(\hat{w},\hat{w}')$. In the former case IV2 holds trivially by the end of the iteration since $A(\hat{w})$ can only increase. For the latter case we distinguish two scenario's. 
			
			First we consider the case where vertex $\hat{v}'$ that is considered during the iteration (line 3 of the algorithm) is $\hat{w}'$. There is a vertex $c \in E(\hat{w},\hat{w}')$ by IV2. Therefore we can conclude that $\hat{w}$ is considered in the for loop starting at line $4$ and will be attracted in lines 8-14 and added to $A(\hat{w})$ in line 19. Therefore IV2 holds by the end of the iteration.
			
			Next we consider the case where $\hat{v}' \neq \hat{w}'$. In this case by the end of the iteration $\hat{w}'$ will still be in $Q$ and IV2 holds.
		\end{itemize}
	
		When the while loop ends IV1 and IV2 hold so for every for every $\hat{w} \in \hat{V}$ and $c \in \mathfrak{C}$ that can be attracted to $A$ we have $c \in A(\hat{w})$. Since we start with $A = U$ can conclude the soundness of the algorithm. IV2 shows the completeness.
	\end{proof}
\end{theorem}


\subsubsection{Running time}
We first analyse the running time of the attractor set. The queue can contain at most $c * n$ items. The first for loop occurs at most $c * e$ times. The second $c * n * e$ with $O(n)$ running time. Total $O(c * e * n^2) = O(c*n^4)$.

Define $m = cn$ and $m_d = |\{(c,\hat{v})\ |\ c\in V(\hat{v})\ \wedge\ \Omega(\hat{v}) = d\}|$.

In the recursive algorithm everything runs in $O(m)$ except for the attractor calculation. To get a running time we analyse its recursion. The first subgame decreases $d$ by one, the second subgame decreases the $m$ by one. This gives the following recursion:
\begin{align*}
T(m,d) &\leq T(m, d-1) + T(m-1, d) + O(cn^4)\\
T(m,1) &= O(m)\\
T(0,d) &= O(m)
\end{align*}
From which we get 
\begin{align*}
T(m,d) &\leq T(m, d-1) + T(m-1, d) + O(cn^4)\\
&\leq m*T(m, d-1) + m*O(cn^4) + O(m)\\
&\leq m*T(m, d-1) + (m+1)O(cn^4)\\
T(m,1) &= O(m)
\end{align*}
We will now prove that $T(m,d) \leq (m+d)^dO(cn^4)$ by induction on $d$.

\textbf{Base} $d = 1$: $T(m,1) = O(m) \leq O(cn^4)$.

\textbf{step} 
\[ T(m,d) \leq m*(m+d-1)^{d-1}O(cn^4) + (m+1)O(cn^4) \]
Since $d > 1$ we have $m \leq m+d-1$
\begin{align*}
T(m,d) &\leq (m+d-1)^{d}O(cn^4) + (m+1)O(cn^4)\\
& \leq ((m+d-1)^d + m + 1)O(cn^4)
\end{align*}
We have $(m+d-1)^d + m + 1 \leq (m+d)^d$ (using lemma \ref{lem_md_ineq}), we find:\\
\[ T(m,d) \leq (m+d)^dO(cn^4) \]

We conclude that the running time for the algorithm is $O((cn+d)^dcn^4) = O(cn^4(cn)^d)$.