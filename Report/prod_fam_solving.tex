For solving VPGs we distinguish two general approaches, the first approach is to simply project the VPG to the different configurations and solve all the resulting parity games independently. We call this approach \textit{product} based. Alternatively we solve the VPG \textit{family} based where a VPG is solved in its entirety and similarities are used to improve performance. 

In this next sections we explore family based algorithms, analyse their running time complexity and present the results of experiments conducted to test the performance of the different family based algorithms compared to the product based approach. We aim to solve VPGs originating from model verification problems, such VPGs generally have certain properties that a completely random VPG might not have. In general parity games originating from model verification problems have a relatively low number of distinct priorities compared to the number of vertices (TODO: cite, vertices exponential in nr priorities?). The transition guards of featured transition systems are expressed over features, in general these transition guards will be quite simple specifically excluding or including a small number of features.

In general we can take some existing algorithm to solve parity games with running time complexity $O(T)$ and use the algorithm to solve a VPG product based. For a VPG with configurations $\mathfrak{C}$ this gives a running time complexity of $O(|\mathfrak{C}|T)$.
\input{preliminatires_solving}