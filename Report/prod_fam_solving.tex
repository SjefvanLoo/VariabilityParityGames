In this section we inspect methods so solve VPGs; for convenience we only consider total VPGs. We distinguish two general approaches for solving VPGs, the first approach is to simply project the VPG to the different configurations and solve all the resulting parity games independently; we call this \textit{independently} solving a VPG. Existing parity game algorithms can be used in this approach. Alternatively, we solve the VPG \textit{collectively} where a VPG is solved in its entirety and similarities between the configurations are used to improve performance. 

In this section we explore collective algorithms and analyse their time complexity. We aim to solve VPGs originating from model verification problems, such VPGs generally have certain properties that a random VPG might not have. In general (V)PGs originating from model verification problems have a relatively low number of distinct priorities compared to the number of vertices because new priorities are only introduced when fixed points are nested in the $\mu$-calculus formula. Furthermore the transition guards of FTSs are boolean formula's over features. In general these formula's will be quite simple, specifically excluding or including a small number of features.

When reasoning about time complexities of parity games or VPGs we use $n$ to denote the number of vertices, $e$ the number of edges, and $d$ the number of distinct priorities. When analysing a VPG then we also use $c$ to indicate the number of configurations.