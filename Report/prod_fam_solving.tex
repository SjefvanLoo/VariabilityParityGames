For solving VPGs we distinguish two general approaches, the first approach is to simply project the VPG to the different configurations and solve all the resulting parity games independently. We call this \textit{independently} solving a VPG. Alternatively we solve the VPG \textit{collectively}, where a VPG is solved in its entirety and similarities between the configurations are used to improve performance. 

In the next sections we explore collective algorithms and analyse their time complexity. We aim to solve VPGs originating from model verification problems, such VPGs generally have certain properties that a completely random VPG might not have. In general parity games originating from model verification problems have a relatively low number of distinct priorities compared to the number of vertices because new priorities are only introduced when fixed points are nested in the $\mu$-calculus formula. Furthermore the transition guards of featured transition systems are expressed over features. In general these transition guards will be quite simple, specifically excluding or including a small number of features.
