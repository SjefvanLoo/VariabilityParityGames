\documentclass[aspectratio=169]{beamer}
\setbeamercovered{dynamic}

\usetheme{default}

\usepackage{ wasysym }
\usepackage{array}

\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{tikz,pgfplots}
\tikzset{>=latex}
\usetikzlibrary{arrows,automata,shapes,calc,matrix}
\definecolor{bgTUE}{HTML}{f1efef}
\definecolor{fgTUE}{HTML}{000000}
\definecolor{tokencolor}{HTML}{6792d6}
\definecolor{highlightgraph}{HTML}{aedb81}
\definecolor{semihighlightgraph}{HTML}{d7EDC0}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{Verifying SPLs using parity games expressing variability} % The short title appears at the bottom of every slide, the full title is only on the title page
\newcounter{picite}
\newcounter{piciteb}

\institute[TU/e] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
	\begin{columns}
\begin{column}{0.5\textwidth}
	\centering
	\begin{tikzpicture}[->,scale=0.7, every node/.style={scale=0.8}]
	\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
	\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.6cm]
	
	\node[odd, label=north:$v_1$,fill=teal,text=white] (v1) at (20,20) {5};
	\node[even,label=north:$v_2$,fill=teal,text=white] (v2) at (23,20) {6};
	\node[even,label=north:$v_3$,fill=teal,text=white] (v3) at (26,20) {4};
	
	\node[even,label=west:$v_4$,fill=teal,text=white]  (v4) at (20,17) {1};
	\node[odd, label=north east:$v_5$,fill=olive,text=white] (v5) at (23,17) {2};
	\node[odd, label=east:$v_6$,fill=pink] (v6) at (26,17) {3};
	
	\node[odd, label=south:$v_7$,fill=pink] (v7) at (23,14) {2};
	
	
	\path (v1) edge node[above]{$\{c_1,c_2,c_3\}$} (v2);
	\path (v3) edge node[above]{$\{c_1,c_2,c_3\}$} (v2);
	
	\path (v4) edge node[left]{$\{c_1,c_2\}$} (v1);
	\path (v2) edge node[fill=bgTUE,near start]{$\{c_1,c_2\}$} (v4);
	\path (v4) edge node[above]{$\{c_1,c_3\}$} (v5);
	\path (v5) edge node[fill=bgTUE]{$\{c_1,c_2,c_3\}$} (v2);
	\path (v6) edge node[above]{$\{c_1,c_2\}$} (v5);
	\path (v2) edge node[fill=bgTUE,near start]{$\{c_1,c_3\}$} (v6);
	\path (v6) edge node[right]{$\{c_1,c_3\}$} (v3);
	
	
	\path (v7) edge node[fill=bgTUE]{$\{c_1,c_2,c_3\}$} (v4);
	\path (v5) edge node[left,near start]{$\{c_1,c_3\}$} (v7);
	\path (v7) edge[bend left] node[fill=bgTUE]{$\{c_1,c_2\}$} (v6);
	\path (v6) edge[bend left] node[fill=bgTUE]{$\{c_1,c_2\}$} (v7);
	\end{tikzpicture}
\end{column}
	\begin{column}{0.5\textwidth}
		\centering
			\large
			Sjef van Loo\\
			\medskip\small
			6 November, 2019\\
			\bigskip
			\bigskip
			\bigskip
			\bigskip
			\bigskip
			\bigskip
\textit{Msc Thesis \\
Computer Science and Engineering\\
\medskip
Supervised by T.A.C. Willemse}\\
\end{column}
\end{columns}
}
\date{November 6, 2019} % Date, can be changed to a custom date
\setbeamertemplate{footline}[frame number]
\begin{document}
	\setbeamercolor{footline}{bg=white}
\setbeamercolor{normal text}{fg=fgTUE,bg=bgTUE}\usebeamercolor*{normal text}
\setbeamercolor{title}{fg=fgTUE}
\setbeamercolor{subtitle}{fg=fgTUE}
\setbeamercolor{titlelike}{fg=fgTUE}
\setbeamercolor{alerted text}{fg=fgTUE}
\setbeamercolor{example text}{fg=fgTUE}

%\setbeamercolor{structure}{fg=fgTUE}

\setbeamercolor{background canvas}{parent=normal text}
%\setbeamercolor{background}{parent=background canvas}

\setbeamercolor{palette primary}{fg=fgTUE,bg=bgTUE} % changed this
\setbeamercolor{palette secondary}{use=structure,fg=fgTUE} % changed this
\setbeamercolor{palette tertiary}{use=structure,fg=fgTUE} % changed this
\setbeamercolor{box1}{fg=fgTUE,bg=white}
\setbeamercolor{itemize item}{fg=fgTUE,bg=white}
\setbeamercolor{itemize subitem}{fg=fgTUE,bg=white}
\setbeamercolor{itemize subsubitem}{fg=fgTUE,bg=white}
\setbeamercolor{enumerate item}{fg=fgTUE,bg=white}
\setbeamercolor{enumerate subitem}{fg=fgTUE,bg=white}
\setbeamercolor{enumerate subsubitem}{fg=fgTUE,bg=white}
\setbeamertemplate{footline}{
	{%
		\leavevmode%
		\hbox{%
			\begin{beamercolorbox}[wd=.1\paperwidth,ht=3ex,dp=1ex,right]{box1}%
				\insertframenumber
			\end{beamercolorbox}%
			\begin{beamercolorbox}[wd=0.05\paperwidth,ht=3ex,dp=1ex,left]{box1}%
			\end{beamercolorbox}%
			\begin{beamercolorbox}[wd=0.7\paperwidth,ht=3ex,dp=1ex,left]{box1}%
				\inserttitle
			\end{beamercolorbox}%
			\begin{beamercolorbox}[wd=0.12\paperwidth,ht=3ex,dp=1ex,right]{box1}%
				\includegraphics[height=3ex]{TUE}
			\end{beamercolorbox}%
			\begin{beamercolorbox}[wd=0.03\paperwidth,ht=3ex,dp=1ex,right]{box1}%
			\end{beamercolorbox}}%
}}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}
%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Outline}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\begin{itemize}
			\item Verification \& SPLs
			\item Problem statement
			\item Variability Parity Games \& algorithms
			\item Experimental results
			\item Conclusions
		\end{itemize}
	\end{column}
	\begin{column}{0.5\textwidth}
	\end{column}
\end{columns}
\end{frame}

%------------------------------------------------

\begin{frame}[t]
\frametitle{Verification}
	\begin{itemize}
		\item Creating correct software is difficult
		\item Even when testing is done rigorously errors can slip in\pause
		\item Mathematically \textit{model the behaviour} of software (LTS)
		\item Mathematically \textit{specify a requirement} (modal $\mu$-calculus)\pause
		\item Check if the model satisfies the requirement
	\end{itemize}
\begin{center}
	\begin{tikzpicture}[->]
	\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
	\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
	
	\node (lts) at (1,3.5)  {LTS $M$};
	\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
	\node (check)at (3,1.5){$M$ satisfies $\varphi$?};
	
	\path[-] (lts) edge (3,2.5);
	\path[-] (form)edge (3,2.5);
	\path (3,2.5)  edge (check);
	\end{tikzpicture}
\end{center}
\end{frame}
%------------------------------------------------

\begin{frame}[t]
\frametitle{Software product lines}
\begin{itemize}
	\item Software product lines are configurable systems
	\item Many variants of the same system, i.e. \textit{software products}
	\item \textit{e.g.} an elevator that can be configured to detect overload\pause
	\item FTSs can be used to model the entire system using \textit{features}\pause
	\item An FTS can be transformed to an LTS given a specific feature assignment
\end{itemize}
\end{frame}
%------------------------------------------------

\begin{frame}[t]
\frametitle{Problem statement}
	\begin{itemize}
		\item Find all the products in an SPL that satisfy a requirement
	\end{itemize}
	\begin{center}
		\begin{tikzpicture}[->]
		\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
		\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
		
		\node (lts) at (1,3.5)  {FTS $M$};
		\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
		\node (check)at (3,1.5) {Which products in $M$ satisfy $\varphi$?};
		
		\path[-] (lts) edge (3,2.5);
		\path[-] (form)edge (3,2.5);
		\path (3,2.5)  edge (check);
		\end{tikzpicture}
	\end{center}
	\begin{itemize}
		\item Do so more efficiently than verifying every product independently
	\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Variability parity game}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\large Parity game: $(V,V_0,V_1,E,\Omega)$\small\\
		Players 0 (even,$\Diamond$) and 1 (odd,$\square$)\\
			\setcounter{picite}{0}%
			\def\showprio{0}
			\def\token{0}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{1}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{3}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{4}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{5}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{2}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{4}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{5}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{2}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}\pause%
			\def\token{-1}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}
			\def\showprio{1}%
			\setcounter{piciteb}{\thepicite}\stepcounter{piciteb}%
			\stepcounter{picite}\only<\thepicite-\thepiciteb>{\input{tikz_pg_example}}%
			\def\token{1}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}%
			\def\token{3}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}%
			\def\token{1}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_example}}%
			\def\token{-1}%
			\stepcounter{picite}\only<\thepicite-|handout:0>{\input{tikz_pg_example}}%
		\begin{itemize}
			\item Infinite path starting at some vertex\pause
			\item The winner is determined by the parity of the priority occurring infinitely often\pause
			\pause\pause\pause%display game
			\item Player 1 wins $\{v_1,v_3\}$, using $v_3 \mapsto v_1$\pause
			\item Player 0 wins $\{v_2,v_4,v_5\}$, using $v_2 \mapsto v_4$\pause\stepcounter{picite}
			\item \textit{Solving}: Partition the vertices in $W_0,W_1$\pause\stepcounter{picite}
		\end{itemize}
	\end{column}
	\begin{column}{0.5\textwidth}
		\large Variability parity game:\small\\%$(V,V_0,V_1,E,\Omega,\mathfrak{C},\theta)$\\
		$(V,V_0,V_1,E,\Omega,\mathfrak{C},\theta)$\\
			\def\showprio{1}%
			\def\token{-1}%%%
			\def\playconf{0}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_vpg_example}}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_vpg_example}}%
			\def\playconf{1}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_vpg_example}}%
			\def\playconf{2}%
			\stepcounter{picite}\only<\thepicite>{\input{tikz_vpg_example}}%
			\def\playconf{0}%
			\stepcounter{picite}\only<\thepicite->{\input{tikz_vpg_example}}%
		\begin{itemize}\pause
			\item Played for a specific configuration $c \in \mathfrak{C}$\pause
			\item $W_0^{c_1} = \emptyset$,$W_1^{c_1} = \{v_1,\dots,v_5\}$\pause
			\item $W_0^{c_2} = \{v_1,v_3\}$,$W_1^{c_2} = \{v_2,v_4,v_5\}$\pause
			\item \textit{Solving}: Partition the vertices in $W_0^c,W_1^c$, for every $c \in \mathfrak{C}$
		\end{itemize}
	\end{column}
\end{columns}
\end{frame}
%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Variability parity game}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\begin{center}
			\setcounter{picite}{0}%
			\stepcounter{picite}\only<\thepicite>{\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node (lts) at (1,3.5)  {LTS $M$};
			\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
			\node (check)at (3,1.5){$M$ satisfies $\varphi$?};
			
			\path[-] (lts) edge (3,2.5);
			\path[-] (form)edge (3,2.5);
			\path (3,2.5)  edge (check);
			\end{tikzpicture}}\pause
			\setcounter{piciteb}{\thepicite}%
			\stepcounter{piciteb}\stepcounter{piciteb}\stepcounter{piciteb}%
			\stepcounter{picite}\only<\thepicite-\thepiciteb>{\begin{tikzpicture}[->]
				\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
				\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
				
				\node (lts) at (1,3.5)  {LTS $M$};
				\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
				\node (PG)at (3,2.5) {PG};
				\node (check)at (3,1.5){$M$ satisfies $\varphi$?};
				
				\path[-] (lts) edge (PG);
				\path[-] (form)edge (PG);
				\path (PG)  edge (check);
			\end{tikzpicture}}
			\begin{theorem}
				A parity game can be constructed from an LTS and a modal $\mu$-calculus formula $\varphi$ such that $M$ satisfies $\varphi$ iff special vertex $v_0$ is won by player 0 in the resulting parity game.
			\end{theorem}
		\end{center}
	\end{column}
	\begin{column}{0.5\textwidth}\pause
		\begin{center}
			\stepcounter{picite}\only<\thepicite>{\begin{tikzpicture}[->]
				\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
				\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
				
				\node (lts) at (1,3.5)  {FTS $M$};
				\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
				\node (check)at (3,1.5){Which products in $M$ satisfy $\varphi$?};
				
				\path[-] (lts) edge (3,2.5);
				\path[-] (form)edge (3,2.5);
				\path (3,2.5)  edge (check);
			\end{tikzpicture}}\pause
			\setcounter{piciteb}{\thepicite}%
			\stepcounter{piciteb}%
			\stepcounter{picite}\only<\thepicite>{\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node (lts) at (1,3.5)  {FTS $M$};
			\node (form)at (5,3.5)  {Modal $\mu$-calculus formula $\varphi$};
			\node (VPG)at (3,2.5) {VPG};
			\node (check)at (3,1.5){Which products in $M$ satisfy $\varphi$?};
			
			\path[-] (lts) edge (VPG);
			\path[-] (form)edge (VPG);
			\path (VPG)  edge (check);
			\end{tikzpicture}}
			\begin{theorem}
				A VPG can be constructed from an FTS and a modal $\mu$-calculus formula $\varphi$ such that $M$ satisfies $\varphi$ for product $p$ iff special vertex $v_0$ is won by player 0 in the resulting VPG played for $p$.
			\end{theorem}\pause
			\stepcounter{piciteb}\only<\thepiciteb>{\begin{tikzpicture}
				\node (FTSM) at (10,10) {FTS};
				\node[opacity=0] (VPGG) at (15,10) {VPG};
				\node (LTSMp) at (10,8) {LTS};
				\node (PGGp) at (15,8) {PG};
				
				\path[->,opacity=0] (FTSM) edge node[above]{$\varphi$} (VPGG);
				\path[->] (LTSMp) edge node[above]{$\varphi$} (PGGp);
				\path[->,dashed] (FTSM) edge node[left]{$\Pi_p$} (LTSMp);
				\path[->,dashed,opacity=0] (VPGG) edge node[right]{$\Pi_p$} (PGGp);
			\end{tikzpicture}}
			\stepcounter{piciteb}\only<\thepiciteb>{\begin{tikzpicture}
				\node (FTSM) at (10,10) {FTS};
				\node (VPGG) at (15,10) {VPG};
				\node (LTSMp) at (10,8) {LTS};
				\node (PGGp) at (15,8) {PG};
				
				\path[->] (FTSM) edge node[above]{$\varphi$} (VPGG);
				\path[->] (LTSMp) edge node[above]{$\varphi$} (PGGp);
				\path[->,dashed] (FTSM) edge node[left]{$\Pi_p$} (LTSMp);
				\path[->,dashed] (VPGG) edge node[right]{$\Pi_p$} (PGGp);
			\end{tikzpicture}}
		\end{center}
	\end{column}
\end{columns}
\end{frame}

%----------------------------------------------------------------------------------------
\begin{frame}[t]
\frametitle{VPG algorithms}
	\begin{itemize}
		\item Solve VPGs \textit{independently}; solve every parity game expressed by the VPG
		\item Solve VPGs \textit{collectively}; solve the VPG as a whole\pause
		\item Introduced two collective algorithms
		\begin{itemize}
			\item Recursive algorithm
			\item Incremental pre-solve algorithm
		\end{itemize}
		\item Evaluate performance of independent approach vs collective approach
	\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------
\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\textit{Attractor} calculation: Find all vertices from where player $\alpha$ can force the play to a vertex in $U$.\\\pause
		\small Example: $\alpha = 0$,$U = \{v_4\}$
		\def\highlighteda{0}%
		\def\highlightedb{0}%
		\def\highlightedc{0}%
		\def\highlightedd{1}%
		\def\highlightede{0}%
		\def\highlightedf{0}%
		\def\highlightedg{0}%
		\def\highlightedh{0}%
		\setcounter{picite}{0}\stepcounter{picite}%
		\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_attr}}%
		\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_attr}}%
		\def\highlightede{1}%
		\def\highlightedh{1}%
		\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_attr}}%
		\def\highlightedc{1}%
		\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_attr}}%
		\def\highlightedf{1}%
		\stepcounter{picite}\only<\thepicite>{\input{tikz_pg_attr}}%
		\def\highlightedg{1}%
		\stepcounter{picite}\only<\thepicite->{\input{tikz_pg_attr}}%
		\bigskip\bigskip
	\end{column}
	\begin{column}{0.5\textwidth}
		\setcounter{picite}{0}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}%
		\only<\thepicite-\the\numexpr\value{picite}+5\relax>{%
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		& $v_1$&$v_2$&$v_3$&$v_4$&$v_5$&$v_6$&$v_7$&$v_8$\\ \hline
		$A$ & & & \only<\the\numexpr\value{picite}+2\relax->{$\checkmark$} & $\checkmark$ & \only<\the\numexpr\value{picite}+1\relax->{$\checkmark$} & \only<\the\numexpr\value{picite}+3\relax->{$\checkmark$} & \only<\the\numexpr\value{picite}+4\relax->{$\checkmark$} & \only<\the\numexpr\value{picite}+1\relax->{$\checkmark$}\\ \hline
	\end{tabular}}
	\stepcounter{picite}\pause\stepcounter{picite}\pause\stepcounter{picite}\pause\stepcounter{picite}\pause\stepcounter{picite}\pause\stepcounter{picite}\pause%
		\only<\thepicite>{%
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		& $v_1$&$v_2$&$v_3$&$v_4$&$v_5$&$v_6$&$v_7$&$v_8$\\ \hline
		$A_0$ & & & & $\checkmark$ & & & &\\ \hline
		$A_1$ & & & & $\checkmark$ & $\checkmark$& & &$\checkmark$\\ \hline
		$A_2$ & & & $\checkmark$& $\checkmark$ & $\checkmark$& & &$\checkmark$\\ \hline
		$A_3$ & & & $\checkmark$& $\checkmark$ & $\checkmark$& $\checkmark$& &$\checkmark$\\ \hline
		$A_4$ & & & $\checkmark$& $\checkmark$ & $\checkmark$& $\checkmark$&$\checkmark$ &$\checkmark$\\ \hline
		$A_5$ & & & $\checkmark$& $\checkmark$ & $\checkmark$& $\checkmark$& $\checkmark$&$\checkmark$\\ \hline
	\end{tabular}	
}
	\end{column}
\end{columns}
	\begin{align*}
	A_0 = U,A& = \cup_{i\geq 0}\ A_i\\
	A_{i+1} = A_i &\cup \{v \in V_\alpha\ |\ \exists_w\ : (v,w) \in E \wedge w \in A_i \} \\
	 &\cup \{v \notin V_\alpha\ |\ \forall_w\ : (v,w) \in E \implies w \in A_i \}\\
	\end{align*}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm}
\begin{columns}[T]
	\begin{column}{0.48\textwidth}
		Find a set of configurations for every vertex.\\
		\small $\mathfrak{C} = \{c_1,c_2\}$
		\setcounter{picite}{0}%
		\def\highlighteda{0}%
		\def\highlightedb{0}%
		\def\highlightedc{0}%
		\def\highlightedd{2}%
		\def\highlightede{0}%
		\def\highlightedf{0}%
		\def\highlightedg{0}%
		\def\highlightedh{0}%
		\stepcounter{picite}\only<\thepicite>{%
			\input{tikz_vpg_attr}%
		}%
		\stepcounter{picite}\only<\thepicite>{%
			\input{tikz_vpg_attr}%
		}%
		\stepcounter{picite}\only<\thepicite>{%
			\input{tikz_vpg_attr}%
		}%
		\def\highlightede{2}%
		\def\highlightedc{1}%
		\def\highlightedh{1}%
		\stepcounter{picite}\only<\thepicite>{%
			\input{tikz_vpg_attr}%
		}%
	\stepcounter{picite}\only<\thepicite>{%
	\input{tikz_vpg_attr}%
}%
\stepcounter{picite}\only<\thepicite>{%
\input{tikz_vpg_attr}%
}%
		\def\highlightedc{2}%
		\def\highlightedf{1}%
		\stepcounter{picite}\only<\thepicite>{%
		\input{tikz_vpg_attr}%
		}%
		\def\highlightedf{2}%
		\stepcounter{picite}\only<\thepicite>{%
		\input{tikz_vpg_attr}%
		}%
		\def\highlightedg{1}%
		\stepcounter{picite}\only<\thepicite>{%
		\input{tikz_vpg_attr}%
		}%
		\pause
	\end{column}
	\begin{column}{0.52\textwidth}
		$A : V \rightarrow 2^\mathfrak{C}$\\
		\footnotesize
		\setcounter{picite}{0}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}%
		\only<\thepicite->{%
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
			\hline
			&$v_1$ &$v_2$ &$v_3$ &$v_4$ &$v_5$ &$v_6$ &$v_7$ &$v_8$ \\ \hline
			$A_0$ & & & &$\mathfrak{C}$& & & &  
			\stepcounter{picite}\only<\thepicite->{\\ \hline$A_1$ & & &$\{c_2\}$ &$\mathfrak{C}$&$\mathfrak{C}$ & & &$\{c_1\}$}%
			\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}\only<\thepicite->{\\ \hline$A_2$ & & &$\mathfrak{C}$ &$\mathfrak{C}$&$\mathfrak{C}$ &$\{c_2\}$& &$\{c_1\}$}%
			\stepcounter{picite}\only<\thepicite->{\\ \hline$A_3$ & & &$\mathfrak{C}$ &$\mathfrak{C}$&$\mathfrak{C}$ &$\mathfrak{C}$& &$\{c_1\}$}%
			\stepcounter{picite}\only<\thepicite->{\\ \hline$A_4$ & & &$\mathfrak{C}$ &$\mathfrak{C}$&$\mathfrak{C}$ &$\mathfrak{C}$&$\{c_1\}$ &$\{c_1\}$ }\\ \hline
		\end{tabular}}
	\setcounter{picite}{0}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}%
\only<\thepicite>{
	\begin{align*}
	A_1(v_5) &= A_0(v_5) \cup (\theta(v_5,v_4) \cap A_0(v_4))\\
	&= \emptyset \cup (\mathfrak{C} \cap \mathfrak{C}) = \mathfrak{C}\\
	\end{align*}}
\stepcounter{picite}\only<\thepicite>{	\begin{align*}
	A_1(v_8) &= A_0(v_8) \cup (\theta(v_8,v_8) \cap A_0(v_8)) \\
	&\cup (\theta(v_8,v_4) \cap A_0(v_4))\\
	&= \emptyset \cup (\mathfrak{C} \cap \emptyset) \cup (\{c_1\} \cap \mathfrak{C}) = \{c_1\}
		\end{align*}}
\stepcounter{picite}\only<\thepicite>{
	\begin{align*}	A_1(v_3) &= A_0(v_3) \cup (\\
	& ((\mathfrak{C}\backslash \theta(v_3,v_4)) \cup A_0(v_4)) \cap\\
	& ((\mathfrak{C}\backslash \theta(v_3,v_8)) \cup A_0(v_8)))\\
	&= \emptyset \cup ((\emptyset \cup \mathfrak{C}) \cap (\{c_2\} \cup \emptyset)) = \{c_2\}
	\end{align*}
}
	\end{column}
\end{columns}
\begin{align*}
A_{i+1}(v) = A_i(v) \cup \begin{cases}
\bigcup_{(v,w)\in E}\ (\theta(v,w) \cap A_i(w)) & \text{if }v \in V_\alpha\\
\bigcap_{(v,w)\in E}\ ((\mathfrak{C}\backslash \theta(v,w)) \cup A_i(w)) & \text{if }v \notin V_\alpha
\end{cases}^*
\end{align*}
\tiny$^*$: Simplified version of the attractor definition presented in the report\pause\pause\pause\pause
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm - Symbolically representing sets}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\begin{itemize}
			\item Represent sets simply as a collection of all its elements (\textit{explicit})
			\item Alternatively, represent sets as boolean formulas (\textit{symbolic})\pause
			\item Example: $S = \{s_0,\dots,s_{7}\}$, $T = \{s_2,s_4,s_6,s_7\}$
			\item Boolean variables: $x_2,x_1,x_0$
			\setcounter{picite}{0}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}%
			\stepcounter{picite}\only<\thepicite->{%
			\item Boolean formulas can be very small
			\item \textit{e.g.} $T = \{s_0,\dots,s_3\}$ can be expressed as $\neg x_2$
			\item \textit{e.g.} $S$ can be expressed as $\textbf{true}$}
			\stepcounter{picite}\only<\thepicite->{%
			\item Boolean operators $\vee,\wedge$ coincide with set operators $\cup,\cap$}
		\end{itemize}
	\end{column}
	\begin{column}{0.5\textwidth}
		\setcounter{picite}{0}\stepcounter{picite}\stepcounter{picite}\stepcounter{picite}%
		\only<\thepicite->{%
		Boolean formula:
		\[F(x_2,x_1,x_0) = (\neg x_2 \wedge x_1 \wedge \neg x_0) \vee (x_2\wedge (x_1 \vee \neg x_0))\]
		\begin{tabular}{|c|c|}
			\hline 
			$\mathbf{x_2x_1x_0}$ & $\mathbf{F(x_2,x_1,x_0)}$ \\ 
			\hline 
			000 & 0 \\ 
			\hline 
			001 & 0 \\ 
			\hline 
			010 & 1 \\ 
			\hline 
			011 & 0 \\ 
			\hline 
			100 & 1 \\ 
			\hline 
			101 & 0 \\ 
			\hline 
			110 & 1 \\ 
			\hline 
			111 & 1 \\ 
			\hline
		\end{tabular}
	}\pause\pause\pause
	\end{column}
\end{columns}
\end{frame}
%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm - Symbolically representing sets}
	\begin{itemize}
		\item Boolean formulas can be expressed as BDDs
		\item Simple formulas $\implies$ small BDDs $\implies$ quick set operators\pause
		\item FTSs use features
		\item FTSs use boolean formulas to enable/disable parts of the system\pause
		\item VPGs are constructed such that every edge either:
		\begin{itemize}
			\item admits all configurations, or
			\item is guarded by a set that coincides with a formula from the FTS
		\end{itemize}
	\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm - Set operations}
\begin{itemize}
	\item Explicitly: $O(c)$
	\item Symbolically: $O(c^2)$
	\item In practice, if the BDDs are small then a symbolic representation outperforms an explicit representation
\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------


\begin{frame}[t]
\frametitle{VPG algorithms - Recursive algorithm - Time complexities}
\small$n$: \# vertices, $e$: \# edges, $d$: \# distinct priorities, $c$ \# configurations\normalsize
\begin{itemize}
	\item Original recursive algorithm: $O(e*n^d)$
	\item Independently solving a VPG, \textit{i.e.} solve $c$ parity games: $O(c*e*n^d)$\pause
	\item Collective recursive algorithm:
	\begin{itemize}
		\item with explicit configuration sets: $O(n*c^2*e*n^d)$
		\item with symbolic configuration sets: $O(n*c^3*e*n^d)$
	\end{itemize} 
\end{itemize}
\end{frame}
%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Experimental results - SPL games}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\large Minepump SPL\\\normalsize
		\begin{itemize}
			\item Keep a mine shaft free from water
			\item 10 features that change the sensor/actor setup\pause
			\item 128 valid feature assignments
			\item 600 states and 1400 transitions
			\item 9 requirements
			\item 9 VPGs ranging from 3000 to 9200 vertices and 2 to 4 distinct priorities
		\end{itemize}
	\end{column}\pause
	\begin{column}{0.5\textwidth}
		\large Elevator SPL\\\normalsize
		\begin{itemize}
			\item Elevator travelling between five floor
			\item 5 features, including overload detection and parking\pause
			\item 64 valid feature assignments
			\item 34k states and 200k
			\item 7 requirements
			\item 7 VPGs ranging from 440k and 1.85m vertices and 2 to 3 distinct priorities
		\end{itemize}
	\end{column}
\end{columns}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Experimental results - SPL games}
\def\scalegraphs{0.6}
\begin{columns}[T]
	\begin{column}{0.5\textwidth}
		\begin{figure}[H]
			\input{"../results/minepump/Zlnk product based_Zlnk fam based - explicit_Zlnk fam based - symbolic_"}
			\caption{Running times, in ms, on the minepump games.}
			\label{fig:results_minepump}
		\end{figure}%
	\end{column}
	\begin{column}{0.5\textwidth}
		\begin{figure}[H]
			\input{"../results/elevator/Zlnk product based_Zlnk fam based - explicit_Zlnk fam based - symbolic_"}
			\caption{Running times, in ms, on the elevator games.}
			\label{fig:results_elevator}
		\end{figure}%
	\end{column}
\end{columns}
\small
\raisebox{.7\height}{\begin{tikzpicture}
	\path[line width=2pt,color=cyan] (19,20) edge (20,20);
	\end{tikzpicture}} Independent recursive algorithm\\
\raisebox{.7\height}{\begin{tikzpicture}
	\path[line width=2pt,color=green] (19,20) edge (20,20);
	\end{tikzpicture}} Collective recursive algorithm with a symbolic representation of configurations\\
\raisebox{.7\height}{\begin{tikzpicture}
	\path[line width=2pt,color=red] (19,20) edge (20,20);
	\end{tikzpicture}} Collective recursive algorithm with an explicit representation of configurations\\
\end{frame}


%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Discussion}
	\large Collective recursive algorithm:\\
	\begin{itemize}
		\item Symbolic variant increases performance 3-18 times (SPL games)
		\item For certain random games the symbolic performance drops rapidly, explicit performance is steady
	\end{itemize}\pause
	\large Incremental pre-solve algorithm:\\
	\begin{itemize}
		\item Slightly increases performance of SPL games and random games
		\item Not consistent or very significant
	\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Locally solving (V)PGs}
\begin{itemize}
	\item Parity games: Terminate when special vertex $v_0$ is solved
	\item VPGs: Terminate when special vertex $v_0$ is solved for all configurations\pause
	\item Introduced local variants of existing algorithms and of the novel VPG algorithms\pause
	\item Relative performance: How much quicker are the collective algorithms?
	\item Is the relative local performance greater than the relative global performance?
\end{itemize}\pause
\large Results:
\begin{itemize}
	\item Recursive algorithms: no significant increase in relative performance
	\item Incremental pre-solve algorithm: increases relative performance for random games
\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------

\begin{frame}[t]
\frametitle{Conclusions}
\begin{itemize}
	\item VPGs can be used to verify SPLs
	\item Collective approaches outperform independent approaches
	\item Locally solving VPGs can increase performance (more so than locally solving parity games does)
\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------

\end{document}