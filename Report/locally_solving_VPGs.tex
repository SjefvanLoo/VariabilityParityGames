As discussed in the preliminaries, parity games can be solved either globally or locally. Similar to parity games we can solve VPGs either globally or locally. When locally solving a VPG for vertex $\hat{v}_0$ we determine for every configuration the winner of vertex $\hat{v}_0$. When globally solving a VPG we determine this for every vertex in the VPG.

When solving a VPG globally we might encounter significant differences in parts of the game or intermediate results between configurations that we perhaps do not encounter when solving it locally because we can terminate earlier. Therefore we hypothesize that the increase in performance between globally-collectively solving VPGs and locally-collectively solving VPGs is greater than the increase in performance between globally-independently solving VPGs and locally-independently solving VPGs.

The algorithms we have seen thus far are global algorithms. In this section we introduce local variants for the parity game algorithms we have seen: Zielonka's recursive algorithm and fixed-point iteration algorithm. Furthermore we introduce local variants for the VPG algorithms we have seen: the recursive algorithm for VPGs and the incremental pre-solve algorithm.

\section{Locally solving parity games}
The two parity game algorithms introduced in the preliminaries (Zielonka's recursive algorithm and the fixed-point iteration algorithm) can be turned into local variants. These local variants can be used to solve VPGs locally and independently.

\subsection{Local recursive algorithm for parity games}
\label{sec:zlnk_org_local}
The recursive algorithm has two recursion steps. The first recursion step gives two winning sets which are used to find set $B$ such that all the vertices in $B$ won are by a particular player. The second recursion step solves the remaining part of the game. When locally solving a parity game we can sometimes avoid entering the second recursion when we already found the vertex we are interested in to be in set $B$. In this section we introduce an algorithm that utilizes this idea to create a local variant of the recursive algorithm.

First we inspect the notion of \textit{traps} \cite{ZIELONKA1998135}. Traps are used in the original proof of the recursive algorithm and we will use them again to reason about a local variant of the recursive algorithm. Consider total parity game $(V,V_0,V_1,E,\Omega)$ in the next definition and two lemma's.
\begin{definition}\cite{ZIELONKA1998135}
	Set $X \subseteq V$ is an $\alpha$-trap in $G$ if and only if player $\overline{\alpha}$ can play in such a way that once the token is in $X$, it will not leave $X$.
\end{definition}
\begin{lemma}\label{lem_attr_is_trap}
	\cite{ZIELONKA1998135}
	Set $V\backslash \alpha\textit{-Attr}(G,X)$ is an $\alpha$-trap in $G$ for any non-empty $X \subseteq V$.
\end{lemma}
\begin{lemma}
	\label{lem_attr_trap_is_trap}\cite{ZIELONKA1998135}
	Let $X \subseteq V$ be an $\alpha$-trap in $G$. Then $\overline{\alpha}\textit{-Attr}(G,X)$ is also an $\alpha$-trap in $G$.
\end{lemma}
Observe that a winning set $W_\alpha$ of parity game $G$ is an $\overline{\alpha}$-trap in $G$. If $\overline{\alpha}$ could play to $W_{\overline{\alpha}}$ from a vertex $v \in W_\alpha$ then $v$ would be winning for $\overline{\alpha}$.


We show that if a vertex in the first recursion is won by player $\overline{\alpha}$, as calculated in the recursive algorithm, then this vertex is also won by player $\overline{\alpha}$ in the game itself.
\begin{lemma}
	\label{lem_overlinealphawinner}
	Given total parity game $G = (V,V_0,V_1,E,\Omega)$, player $\alpha \in \{0,1\}$ and non-empty set $X \subseteq V$ it holds that the winning set $W_{\overline{\alpha}}$ for player $\overline{\alpha}$ in  $G' = G \backslash \alpha\textit{-Attr}(G,X)$ is an $\alpha$-trap in $G$ and all vertices in $W_{\overline{\alpha}}$ are winning for $\overline{\alpha}$ in $G$.
	\begin{proof}
		Using Lemma \ref{lem_attr_is_trap} we find that $V' = V \backslash \alpha\textit{-Attr}(G,X)$ is a an $\alpha$-trap in $G$. Set $W_{\overline{\alpha}}$ is an $\alpha$-trap in $G$ because if $\alpha$ could escape to $V \backslash V'$ then $V'$ would not be an $\alpha$-trap in $G$ and if $\alpha$ could escape to $V' \backslash W_{\overline{\alpha}}$ then $W_{\overline{\alpha}}$ would not be an $\alpha$-trap in $G'$. Moreover keeping the token in $W_{\overline{\alpha}}$ causes player $\overline{\alpha}$ to win the path because the strategy that was winning in $G'$ can also be applied in $G$.
	\end{proof}
\end{lemma}

Let $v_0$ be the vertex we are trying to solve locally. We could argue that if the algorithm finds $v_0$ to be winning for player $\overline{\alpha}$ in the first recursion of the algorithm then we can terminate and report $v_0$ to be winning for $\overline{\alpha}$. Using the lemma above we find that indeed $v_0$ is winning for player $\overline{\alpha}$ in game $G$ when $v_0$ is winning for $\overline{\alpha}$ in the first recursion. However game $G$ itself might be the subgame of some game $H$. Vertex $v_0$ is winning for $\overline{\alpha}$ in $G$ and in the subgame created in the first recursion; however if we want to terminate early then $v_0$ must also be winning for $\overline{\alpha}$ in game $H$. If $v_0$ is not winning for $\overline{\alpha}$ in game $H$ and game $G$ is the first subgame created from game $H$ then in order to correctly solve game $H$ we need the complete winning sets of $G$. In the conjecture below we express this property. If the conjecture holds we can terminate when we find $v_0$ in the first recursion to be winning for player $\overline{\alpha}$. However, as is shown below, the conjecture does not hold.
\begin{conjecture}[Disproven]
	\label{con_opponent_a_always_wins}
	For any $\textsc{RecursivePG}(G\backslash A)$, with winning sets $(W'_0,W'_1)$, that is invoked during $\textsc{RecursivePG}(G)$ it holds that any vertex $v \in W'_{\overline{\alpha}}$ is won by player $\overline{\alpha}$ in game $G$.
	\begin{proof}[Counterexample]
		Consider the following parity game $G$:
		\begin{center}
			\begin{tikzpicture}[->]
			\tikzstyle{even} = [diamond,draw,minimum size=0.75cm]
			\tikzstyle{odd}  = [rectangle,draw,shape aspect=1,minimum size=0.75cm]
			
			\node[even,label=north:$v_1$] (v1) at (20,20) {1};
			\node[odd, label=north:$v_3$] (v3) at (22,20) {3};
			\node[odd, label=north:$v_2$] (v2) at (24,20) {2};
			
			\path (v1) edge[loop left] (v1);
			\path (v1) edge (v3);
			\path (v3) edge (v2);
			\path (v2) edge[loop right] (v2);
			\end{tikzpicture}
		\end{center}
		
		All vertices are won by player $0$ ($v_1$ plays to $v_3$, $v_3$ must play to $v_2$ and $v_2$ must play to itself; we always get an infinite path of $v_2$'s).
		
		We solve this game using \textsc{RecursivePG} and write down the values of relevant variables below. We use the tilde decoration to indicate values for variables in the first recursion:
		\begin{longtable}{|p{20cm}}
			$\textsc{RecursivePG}(G)$:\\
			$h=3$,$\alpha=1$\\
			$A =\{v_3\}$\\
			\begin{tabular}{|p{20cm}}
				$\textsc{RecursivePG}(G\backslash A)$:\\
				$\tilde{h}=2,\tilde{\alpha}=0$\\
				$\tilde{A}=\{v_2\}$\\
				\begin{tabular}{|p{20cm}}
					$\textsc{RecursivePG}(G\backslash A\backslash \tilde{A})$\\
				\end{tabular}
				$\tilde{W}'_0 = \emptyset$\\
				$\tilde{W}'_1 = \{v_1\} = \tilde{W}'_{\overline{\tilde{\alpha}}}$\\
				\textbf{Vertex $v_1$ is in $\tilde{W}'_{\overline{\tilde{\alpha}}}$ however in $G$ the vertex is won by player} $\tilde{\alpha}$.\\
				$\tilde{B} = \{v_1\}$\\
				\begin{tabular}{|p{20cm}}
					$\textsc{RecursivePG}(G\backslash A\backslash \tilde{B})$\\
				\end{tabular}
				$\tilde{W}''_0 = \{v_2\}, \tilde{W}''_1 = \emptyset$\\
			\end{tabular}
			$W'_0 = W'_{\overline{\alpha}} = \{v_2\}$\\
			$W'_1 = W'_\alpha = \{v_1\}$\\
			$B = V$\\
			\begin{tabular}{|p{20cm}}
				$\textsc{RecursivePG}(G\backslash B)$\\
			\end{tabular}
			$W_0 = W_{\overline{\alpha}} = V$
		\end{longtable}
		
		This counterexample disproves the conjecture.
\end{proof}\end{conjecture}

When $v_0$ is not winning for player $\overline{\alpha}$ in the first recursion then we need the complete winning sets to calculate $B$ and go in the next recursion. We extend the recursive algorithm with a variable $\Delta \subseteq \{0,1\}$. The algorithm either returns partial winning sets, containing $v_0$, when $v_0$ is won by player $\beta\in \Delta$ or the algorithm returns complete winning sets. This solves the problem, that Conjecture \ref{con_opponent_a_always_wins} does not hold, by only allowing the algorithm to terminate before the second recursion when $\overline{\alpha}$ is in $\Delta$. Pseudo code for the algorithm using $\Delta$ is provided in Algorithm \ref{alg_zlnk_local}.
\begin{algorithm}
	\caption{$\textsc{RecursivePGLocal}(\textit{parity game } G = (V,V_0,V_1, E, \Omega),v_0,\Delta)$}
	\label{alg_zlnk_local}
	\begin{algorithmic}[1]
		\If{$V = \emptyset$}
			\State \Return $(\emptyset, \emptyset)$
		\EndIf
		\State $h \gets\max\{ \Omega(v)\ |\ v \in V\}$
		\State $\alpha \gets 0$ if $h$ is even and $1$ otherwise
		\State $U \gets \{v \in V\ |\ \Omega(v) = h\}$
		\State $A \gets \alpha\textit{-Attr}(G, U)$
		\If{$\overline{\alpha} \in \Delta$}\label{line:recursivePGLocal:firstif}
		\State $(W_0', W_1') \gets \textsc{RecursivePGLocal}(G \backslash A,v_0,\{\overline{\alpha}\})$\label{line:recursivePGLocal:recuGA1}
		\Else
		\State $(W_0', W_1') \gets \textsc{RecursivePGLocal}(G \backslash A,v_0,\emptyset)$\label{line:recursivePGLocal:recuGA2}
		\EndIf
		\If{$W_{\overline{\alpha}}' =\emptyset$}\label{line:recursivePGLocal:emptywinif}
		\State $W_\alpha \gets A \cup W_\alpha'$
		\State $W_{\overline{\alpha}} \gets \emptyset$
		\Else
		\State $B \gets \overline{\alpha}\textit{-Attr}(G,W_{\overline{\alpha}}')$\label{line:recursivePGLocal:calcB}
		\If{$\overline{\alpha} \in \Delta \wedge v_0 \in B$}\label{line:recursivePGLocal:v0inB}
		\State $W_\alpha \gets \emptyset$
		\State $W_{\overline{\alpha}} \gets B$
		\Else
		\State $(W_0'', W_1'') \gets \textsc{RecursivePGLocal}(G \backslash B,v_0,\Delta)$\label{line:recursivePGLocal:secondrecursion}
		\State $W_\alpha \gets W_\alpha''$
		\State $W_{\overline{\alpha}} \gets W_{\overline{\alpha}}'' \cup B$
		\EndIf
		\EndIf
		\State \Return $(W_0, W_1)$
	\end{algorithmic}
\end{algorithm}

To prove the correctness we show any vertex in the winning set $W_\gamma$ resulting from \textsc{RecursivePGLocal} is indeed winning for player $\gamma$ and that either the winning sets completely partition the graph or that vertex $v_0$ is in winning set $W_\beta$ such that $\beta \in \Delta$.

The proof is in many ways similar to the proof given in \cite{ZIELONKA1998135}. We repeat part of the original reasoning in the following lemma.
\begin{lemma}
\label{lem_GwithoutB_is_subset}
	Given:
	\begin{itemize}
		\item total parity game $G = (V,V_0,V_1,E,\Omega)$,
		\item non-empty set $X \subseteq V$ such that $X$ is an $\alpha$-trap in $G$ and all vertices in $X$ are winning for player $\overline{\alpha}$ in game $G$,
		\item subgame $G' = G\backslash \overline{\alpha}$-Attr$(G,X)$
	\end{itemize}
	it holds that the winner of any vertex in $G'$ is also the winner of that vertex in $G$.
	\begin{proof}
		Let $(W'_0, W'_1)$ be the winning sets of game $G'$. Using Lemma \ref{lem_attr_trap_is_trap} we find that $\overline{\alpha}\textit{-Attr}(G,X)$ is an $\alpha$-trap in $G$. Using lemma \ref{lem_attr_is_trap} we find that $V' = V\backslash \overline{\alpha}\textit{-Attr}(G,X)$ is an $\overline{\alpha}$-trap in $G$.
		
		Consider winning set $W'_\alpha$ for game $G'$. Set $W'_\alpha$ is an $\overline{\alpha}$-trap in $G'$. In game $G$ we find that player $\overline{\alpha}$ can not escape $W'_\alpha$ by going to $V\backslash  V'$ because $V'$ is an $\overline{\alpha}$-trap in $G$. Furthermore player $\overline{\alpha}$ can not escape to $W'_{\overline{\alpha}}$ because $W'_\alpha$ is an $\overline{\alpha}$-trap in $G'$. We find that $W_\alpha$ is an $\overline{\alpha}$-trap in $G$. Finally we know that the strategy for player $\alpha$ used in game $G'$ is still applicable in game $G$ to win the vertices in $W'_\alpha$ for game $G$.
		
		Consider winning set $W'_{\overline{\alpha}}$ for game $G'$. Set $W'_{\overline{\alpha}}$ is an $\alpha$-trap in $G'$. In game $G$ we find that player $\alpha$ can not escape $W'_{\overline{\alpha}}$ by going to $W'_\alpha$, however he/she might escape by going to $V\backslash V' = \overline{\alpha}\textit{-Attr}(G,X)$. When play goes to $\overline{\alpha}\textit{-Attr}(G,X)$ then player $\overline{\alpha}$ can get the play into $X$ which is an $\alpha$-trap in $G$ and is winning for player $\overline{\alpha}$ in $G$. So when the token is in $W'_{\overline{\alpha}}$ either the play stays there and $\overline{\alpha}$ uses the strategy from game $G'$ to win or the token goes to $X$ where player $\overline{\alpha}$ can keep the play and win.
	\end{proof}
\end{lemma}
\begin{theorem}
	\label{the_local_zlnk_correct}
	Given total parity game $G = (V,V_0,V_1,E,\Omega)$, vertex $v_0$ (which is not necessarily in $V$), $\Delta \subseteq \{0,1\}$ and winning sets $(Q_0,Q_1)$ for game $G$. We have for sets $(W_0,W_1) = \textsc{RecursivePGLocal}(G,v_0,\Delta)$ that at least one of the following statements hold:
	\begin{enumerate}[(I)]
		\item For some $\beta \in \Delta$ we have $v_0 \in W_\beta$, $W_0 \subseteq Q_0$ and $W_1 \subseteq Q_1$.
		\item $W_0 = Q_0$ and $W_1 = Q_1$.
	\end{enumerate}
		\begin{proof}
			First note that both statements require the vertices in the winning sets to be in the correct winning sets. Statement (I) only allows winning sets to be incomplete, it does not allow vertices to be in a winning set when that vertex is not actually won by that player. Furthermore note that statement (II) simply states that the game is solved completely.
			
			Proof by induction on $G$. 
			
			\textbf{Base}: When $G$ is empty then the algorithm returns $(\emptyset, \emptyset)$ in which case statement (II) holds trivially.
			
			\textbf{Step}: The algorithm considers the highest priority in the game and assigns the parity of this priority to $\alpha$. The set $U$ contains all vertices with this priority and $A$ contains all vertices from where player $\alpha$ can force the play into $U$.
			
			The first recursion removes vertices in $A$ from the game, since $A$ is non-empty we can apply induction to find that at least one of the two statements hold for $G\backslash A$ and winning sets $(W_0',W_1')$.
			
			If $W'_{\overline{\alpha}} = \emptyset$ (line \ref{line:recursivePGLocal:emptywinif}) then statement (II) must be true for $G \backslash A$ because $\alpha$ is never in $\Delta$ for the the recursion $G \backslash A$ (lines \ref{line:recursivePGLocal:recuGA1} and \ref{line:recursivePGLocal:recuGA2}). We find that indeed all vertices in $G\backslash A$ are won by player $\alpha$, moreover player $\alpha$ has a strategy $\sigma_\alpha$ for $G\backslash A$ that is winning for all vertices in $V\backslash A$. Clearly this strategy can also be applied game to $G$. Consider valid path $\pi$ in game $G$ conforming to $\sigma_\alpha$. When this path eventually stays in $V \backslash A$ then player $\alpha$ wins because $\sigma_\alpha$ is winning here. Otherwise the path visits $A$ infinitely often, in which case player $\alpha$ can force the play infinitely often into $U$ and therefore the highest priority occurring infinitely often has parity $\alpha$. So player $\alpha$ wins all vertices in $V$ and the algorithm returns winning sets accordingly; statement (II) holds.
			
			If $W'_{\overline{\alpha}} \neq \emptyset$ we use Lemma \ref{lem_overlinealphawinner} to find that all vertices in $W'_{\overline{\alpha}}$ are also won by player $\overline{\alpha}$ in game $G$.
			
			The algorithm continues with calculating set $B$ (line \ref{line:recursivePGLocal:calcB}). If $\overline{\alpha} \in \Delta$ and $v_0 \in B$ (line \ref{line:recursivePGLocal:v0inB}) then the algorithm returns all vertices in $B$ to be winning for player $\overline{\alpha}$. As argued, all vertices in $W'_{\overline{\alpha}}$ are winning for player $\overline{\alpha}$ in game $G$. Clearly any vertex where player $\overline{\alpha}$ can force the play to $W'_{\overline{\alpha}}$ is also winning for player $\overline{\alpha}$. So all vertices in $B$ are winning for player $\overline{\alpha}$ in $G$. Because $v_0 \in B$ and $\overline{\alpha} \in \Delta$, statement (I) holds for game $G$.
			
			If $\overline{\alpha} \notin \Delta$ or $v_0 \notin B$ then statement(II) holds for game $G\backslash A$ (because $W'_{\overline{\alpha}} \subseteq B$).
			
			The algorithm goes into the second recursion (line \ref{line:recursivePGLocal:secondrecursion}). Using induction we find that any vertex $v \in W''_\beta$ is indeed won by player $\beta$ in game $G\backslash B$. The algorithm returns $v$ to be winning for player $\beta$ in game $G$, using Lemma \ref{lem_GwithoutB_is_subset} we find this to be correct. Note that we can apply Lemma \ref{lem_GwithoutB_is_subset} because statement (II) holds for $G\backslash A$ and using Lemma \ref{lem_overlinealphawinner} we find that $W'_{\overline{\alpha}}$ is an $\alpha$-trap in $G$. The algorithm also returns $B$ to be winning for $\overline{\alpha}$, which is correct because it contains vertices such that player $\overline{\alpha}$ can play to $W'_{\overline{\alpha}}$ where player $\overline{\alpha}$ wins. If statement (II) holds for $G\backslash B$ then statement (II) also holds for $G$. If statement (I) holds for $G\backslash B$ then statement (I) also holds for $G$ because we pass $\Delta$ into the recursion unmodified.
		\end{proof}
\end{theorem}
Calling $\textsc{RecursivePGLocal}(G, v_0, \{0,1\})$ with $v_0$ in $G$ either solves the full game (statement (II)) or correctly puts $v_0$ in either winning set (statement (I)). In both cases $v_0$ is in the correct winning set and the game is solved locally.

The worst-case time complexity of the local variant is the same as the original algorithm: $O(e*n^d)$. If vertex $v_0$ is not winning for a player in $\Delta$ then the algorithm behaves the same as the original so its worst-case time complexity is the same.


\subsection{Local fixed-point iteration algorithm}
The fixed-point iteration algorithm can be modified to locally solve a game for vertex $v_0$ by distinguishing two cases:
\begin{enumerate}
	\item If $d-1$ is even then the outermost fixed-point variable is a greatest fixed-point variable. When at some point $v_0 \notin Z_{d-1}$ then we know $v_0$ is never won by player $0$ and we are done.
	\item If $d-1$ is odd then the outermost fixed-point variable is a least fixed-point variable. When at some point $v_0 \in Z_{d-1}$ then we know $v_0$ is won by player $0$ and we are done.
\end{enumerate}

If vertex $v_0$ is won by player 0 in the first case or won by player 1 in the second case then the algorithm never terminates early. So in the worst-case the local algorithm behaves the same as the global algorithm, therefore we have identical worst-case time complexities of $O(e*n^d)$.

\section{Locally solving variability parity games}
We consider the two collective VPG algorithms we have seen thus far and create local variants of them.
\subsection{Local recursive algorithm for variability parity games}
\input{localrecursivezlnk.tex}

\subsection{Local incremental pre-solve algorithm}
\input{localFPITEalg}